<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>QP/C: 3. The main() Function</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">QP/C Reference Manual</a>      </li>
      <li class="navelem"><a class="el" href="tutorial_page.html">QP/C Tutorial</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">3. The main() Function </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><em>This QP/C Tutorial is adapted from Chapter 1 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a><br/>
 by Miro Samek, the founder and president of Quantum Leaps, LLC.</em></p>
<div class="image">
<img src="qp_tutorial.jpg" alt="qp_tutorial.jpg"/>
</div>
<p>Prev: <a class="el" href="lets_play.html">2. Let's Play</a> <br/>
 Next: <a class="el" href="design.html">4. Designing an Event-Driven Application</a></p>
<p>Perhaps the best place to start the explanation of the "Fly 'n' Shoot" application code is the main() function, located in the file <code>main.c</code>. Unless indicated otherwise in this Tutorial, you can browse the code either in the DOS version, or the ARM-Cortex version, because the application source code is identical in both. The complete <code>main.c</code> file is shown in <a class="el" href="main_function.html#L3s1">Listing 3-1</a></p>
<dl class="note"><dt><b>Note:</b></dt><dd>To explain code listings, I place numbers in parentheses at the interesting lines in the left margin of the listing. I then use these labels in the left margin of the explanation section that immediately follows the listing. Occasionally, to unambiguously refer to a line of a particular listing from sections of text other than the explanation section, I use the full reference consisting of the listing number followed by the label. For example, <a class="el" href="main_function.html#L3s1">Listing 3-1</a>(21) refers to the label (21) in <a class="el" href="main_function.html#L3s1">Listing 3-1</a></dd></dl>
<p><a class="anchor" id="L3s1"></a><b>Listing 3-1 The file main.c of the "Fly 'n' Shoot" game application. </b> </p>
<div class="fragment"><pre class="fragment"> (1) #include <span class="stringliteral">&quot;qp_port.h&quot;</span>                                         <span class="comment">/* the QP port */</span>
 (2) #include <span class="stringliteral">&quot;bsp.h&quot;</span>                                   <span class="comment">/* Board Support Package */</span>
 (3) #include <span class="stringliteral">&quot;game.h&quot;</span>                                       <span class="comment">/* this application */</span>

     <span class="comment">/* Local-scope objects -----------------------------------------------------*/</span>
 (4) static <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> const * l_missileQueueSto[2];                  <span class="comment">/* event queue */</span>
 (5) static <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> const * l_shipQueueSto[3];                     <span class="comment">/* event queue */</span>
 (6) static <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> const * l_tunnelQueueSto[GAME_MINES_MAX + 5];  <span class="comment">/* event queue */</span>
 (7) static ObjectPosEvt   l_smlPoolSto[GAME_MINES_MAX + 8];  <span class="comment">/* small-size pool */</span>
 (8) static ObjectImageEvt l_medPoolSto[GAME_MINES_MAX + 8]; <span class="comment">/* medium-size pool */</span>
 (9) static <a class="code" href="struct_q_subscr_list.html" title="Subscriber-List structure.">QSubscrList</a>    l_subscrSto[MAX_PUB_SIG];        <span class="comment">/* publish-subscribe */</span>

     <span class="comment">/*..........................................................................*/</span>
     <span class="keywordtype">void</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {
                               <span class="comment">/* explicitly invoke the active objects&#39; ctors... */</span>
(10)     Missile_ctor();
(11)     Ship_ctor();
(12)     Tunnel_ctor();

(13)     BSP_init(argc, argv);           <span class="comment">/* initialize the Board Support Package */</span>
(14)     <a class="code" href="qf_8h.html#adac7eccb860d910c4e446d3143798bba" title="QF initialization.">QF_init</a>();     <span class="comment">/* initialize the framework and the underlying RT kernel */</span>

                                                <span class="comment">/* initialize the event pools... */</span>
(15)     <a class="code" href="qf_8h.html#a63817909aa88407fd7d6c1ff3706a249" title="Event pool initialization for dynamic allocation of events.">QF_poolInit</a>(l_smlPoolSto, <span class="keyword">sizeof</span>(l_smlPoolSto), <span class="keyword">sizeof</span>(l_smlPoolSto[0]));
(16)     <a class="code" href="qf_8h.html#a63817909aa88407fd7d6c1ff3706a249" title="Event pool initialization for dynamic allocation of events.">QF_poolInit</a>(l_medPoolSto, <span class="keyword">sizeof</span>(l_medPoolSto), <span class="keyword">sizeof</span>(l_medPoolSto[0]));

(17)     <a class="code" href="qf_8h.html#a9f97f476eb311982be2f2e46011a04e4" title="Publish-subscribe initialization.">QF_psInit</a>(l_subscrSto, <a class="code" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_subscrSto));   <span class="comment">/* init publish-subscribe */</span>

                                                  <span class="comment">/* start the active objects... */</span>
(18)     <a class="code" href="qf_8h.html#a0123f02b4c1bcf7df2cc0b11dfce8b09" title="Starts execution of an active object and registers the object with the framework.">QActive_start</a>(AO_Missile,<span class="comment">/* global pointer to the Missile active object */</span>
                       1,                                   <span class="comment">/* priority (lowest) */</span>
                       l_missileQueueSto, <a class="code" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_missileQueueSto), <span class="comment">/* evt queue */</span>
                       (<span class="keywordtype">void</span> *)0, 0,                      <span class="comment">/* no per-thread stack */</span>
                       (<a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> *)0);                  <span class="comment">/* no initialization event */</span>
(19)     <a class="code" href="qf_8h.html#a0123f02b4c1bcf7df2cc0b11dfce8b09" title="Starts execution of an active object and registers the object with the framework.">QActive_start</a>(AO_Ship,      <span class="comment">/* global pointer to the Ship active object */</span>
                       2,                                            <span class="comment">/* priority */</span>
                       l_shipQueueSto,    <a class="code" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_shipQueueSto),    <span class="comment">/* evt queue */</span>
                       (<span class="keywordtype">void</span> *)0, 0,                      <span class="comment">/* no per-thread stack */</span>
                       (<a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> *)0);                  <span class="comment">/* no initialization event */</span>
(20)     <a class="code" href="qf_8h.html#a0123f02b4c1bcf7df2cc0b11dfce8b09" title="Starts execution of an active object and registers the object with the framework.">QActive_start</a>(AO_Tunnel,  <span class="comment">/* global pointer to the Tunnel active object */</span>
                       3,                                            <span class="comment">/* priority */</span>
                       l_tunnelQueueSto,  <a class="code" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_tunnelQueueSto),  <span class="comment">/* evt queue */</span>
                       (<span class="keywordtype">void</span> *)0, 0,                      <span class="comment">/* no per-thread stack */</span>
                       (<a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> *)0);                  <span class="comment">/* no initialization event */</span>

(21)     <a class="code" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run</a>();                                     <span class="comment">/* run the QF application */</span>
    }
</pre></div><ul>
<li>(1) The "Fly 'n' Shoot" game is an example of an application implemented with the QP event-driven platform. Every application C-file that uses QP must include the <a class="el" href="qp__port_8h_source.html">qp_port.h</a> header file. This header file contains the specific adaptation of QP to the given processor, operating system, and compiler, which is called a port. Each QP port is located in a separate directory and the C compiler finds the right <a class="el" href="qp__port_8h_source.html">qp_port.h</a> header file through the include search path provided to the compiler (typically via the -I compiler option). That way I don't need to change the application source code to recompile it for a different processor or compiler. I only need to instruct the compiler to look in a different QP port directory for the <a class="el" href="qp__port_8h_source.html">qp_port.h</a> header file. For example, the DOS version includes the <a class="el" href="qp__port_8h_source.html">qp_port.h</a> header file from the directory <code>&lt;qpc&gt;\ports\80x86\dos\watcom\l\</code>, and the ARM-Cortex version from the directory <code>&lt;qpc&gt;\ports\arm-cortex\vanilla\iar\</code>.</li>
</ul>
<ul>
<li>(2) The bsp.h header file contains the interface to the Board Support Package and is located in the application directory.</li>
</ul>
<ul>
<li>(3) The game.h header file contains the declarations of events and other facilities shared among the components of the application. I will discuss this header file in the upcoming Section <a class="el" href="events.html">6. Defining Event Signals and Event Parameters</a>. This header file is located in the application directory.</li>
</ul>
<p>The QP event-driven platform is a collection of components, such as the QEP event processor that executes state machines according to the UML semantics and the QF real-time framework that implements the active object computing model. Active objects in QF are encapsulated state machines (each with an event queue, a separate task context, and a unique priority) that communicate with one another asynchronously by sending and receiving events, while QF handles all the details of thread-safe event exchange and queuing. Within an active object, the events are processed by the QEP event processor sequentially in a run-to-completion (RTC) fashion, meaning that processing of one event must necessarily complete before processing the next event.</p>
<ul>
<li>(4-6) The application must provide storage for the event queues of all active objects used in the application. Here the storage is provided at compile time through the statically allocated arrays of immutable (const) pointers to events, because QF event queues hold just pointers to events, not events themselves. Events are represented as instances of the <a class="el" href="struct_q_event.html" title="Event structure.">QEvent</a> structure declared in the <a class="el" href="qp__port_8h_source.html">qp_port.h</a> header file. Each event queue of an active object can have a different size and you need to decide this size based on your knowledge of the application. I discuss the event queues in Chapters 6 and 7 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a>.</li>
</ul>
<ul>
<li>(7-8) The application must also provide storage for event pools that the framework uses for fast and deterministic dynamic allocation of events. Each event pool manages can provide only fixed-size memory blocks. To avoid wasting memory by using oversized blocks for small events, the QF framework can manage up to three event pools of different block sizes (for small, medium, and large events). The "Fly 'n' Shoot" application uses only two out of the three possible event pools (the small and medium pools).</li>
</ul>
<p>The QF real-time framework supports two event delivery mechanisms: the simple direct event posting to active objects, and the more advanced mechanism called publish-subscribe that decouples event producers from the consumers. In the publish-subscribe mechanism, active objects subscribe to events by the framework. Event producers publish the events to the framework. Upon each publication request, the framework delivers the event to all active objects that had subscribed to that event type. One obvious implication of publish-subscribe is that the framework must store the subscriber information, whereas it must be possible to handle multiple subscribers to any give event type. The event delivery mechanisms are described in Chapters 6 and 7 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a>.</p>
<ul>
<li>(9) The "Fly 'n' Shoot" application uses the publish-subscribe event delivery mechanism supported by QF, so it needs to provide the storage for the subscriber lists. The subscriber lists remembers which active objects have subscribed to which events. The size of the subscriber database depends on both the number of published events, which is specified in the MAX_PUB_SIG constant found in the game.h header file, and the maximum number of active objects allowed in the system, which is determined by the QF configuration parameter <a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a>.</li>
</ul>
<ul>
<li>(10-12) These functions perform an early initialization of the active objects in the system. They play the role of static "constructors", which in C you need to invoke explicitly. (C++ calls such static constructors implicitly before entering <code>main()</code>).</li>
</ul>
<ul>
<li>(13) The function <code>BSP_init()</code> initializes the board and is defined in the bsp.c file.</li>
</ul>
<ul>
<li>(14) The function <a class="el" href="qf_8h.html#adac7eccb860d910c4e446d3143798bba" title="QF initialization.">QF_init()</a> initializes the QF component and the underlying RTOS/kernel, if such software is used. You need to call <a class="el" href="qf_8h.html#adac7eccb860d910c4e446d3143798bba" title="QF initialization.">QF_init()</a> before you invoke any of QF services.</li>
</ul>
<ul>
<li>(15-16) The function <a class="el" href="qf_8h.html#a63817909aa88407fd7d6c1ff3706a249" title="Event pool initialization for dynamic allocation of events.">QF_poolInit()</a> initializes the event pools. The parameters of this function are the pointer to the event pool storage, the size of this storage, and the block-size of this pool. You can call this function up to three times to initialize up to three event pools. The subsequent calls to <a class="el" href="qf_8h.html#a63817909aa88407fd7d6c1ff3706a249" title="Event pool initialization for dynamic allocation of events.">QF_poolInit()</a> must be made in the increasing order of block sizes. For instance, the small block-size pool must be initialized before the medium block-size pool.</li>
</ul>
<ul>
<li>(17) The function <a class="el" href="qf_8h.html#a63817909aa88407fd7d6c1ff3706a249" title="Event pool initialization for dynamic allocation of events.">QF_poolInit()</a> initializes the publish-subscribe event delivery mechanism of QF. The parameters of this function are the pointer to the subscriber-list array and the dimension of this array.</li>
</ul>
<p>The utility macro <a class="el" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM(a)</a> provides the dimension of a one-dimensional array <code>a[]</code> computed as <code>sizeof(a)/sizeof(a[0])</code>, which is a compile-time constant. The use of this macro simplifies the code because it allows me to eliminate many #define constants that otherwise I would need to provide for the dimensions of various arrays. I can simply hard-code the dimension right in the definition of an array, which is the only place that I specify it. I then use the macro <a class="el" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM()</a> whenever I need this dimension in the code.</p>
<ul>
<li>(18-20) The function <a class="el" href="qf_8h.html#a0123f02b4c1bcf7df2cc0b11dfce8b09" title="Starts execution of an active object and registers the object with the framework.">QActive_start()</a> tells the QF framework to start managing an active object as part of the application. The function takes the following parameters: the pointer to the active object structure, the priority of the active object, the pointer to its event queue, the dimension (length) of that queue, and three other parameters that I explain in Chapter 7 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a>, since they are not relevant at this point. The active object priorities in QF are numbered from 1 to <a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a>, inclusive, where a higher priority number denotes higher urgency of the active object. The constant <a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a> is defined in the QF port header file <a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C compiler.">qf_port.h</a> and currently cannot exceed 63.</li>
</ul>
<p>I like to keep the code and data of every active object strictly encapsulated within its own C-file. For example, all code and data for the active object Ship are encapsulated in the file ship.c, with the external interface consisting of the function <code>Ship_ctor()</code> and the pointer <code>AO_Ship</code>.</p>
<ul>
<li>(21) At this point, you have provided to the framework all the storage and information it needs to manage your application. The last thing you must do is to call the function <a class="el" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a> to pass the control to the framework.</li>
</ul>
<p>After the call to <a class="el" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a> the framework is in full control. The framework executes the application by calling your code, not the other way around. The function <a class="el" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a> never returns the control back to main(). In the DOS version of the "Fly 'n' Shoot" game, you can terminate the application by pressing the ESC key, in which case <a class="el" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a> exits to DOS, but not to <code>main()</code>. In an embedded system, such as the ARM-Cortex board, <a class="el" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a> runs forever or till the power is removed, whichever comes first.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For best cross-platform portability, the source code uses consistently the <b>UNIX end-of-line convention</b> (lines are terminated with LF only, 0xA character). This convention seems to be working for all C/C++ compilers and cross-compilers, including legacy DOS-era tools. In contrast, the DOS/Windows end-of-line convention (lines terminated with the CR,LF, or 0xD,0xA pair of characters), is known to cause problems on UNIX-like platforms, especially in the multi-line preprocessor macros.</dd></dl>
<p>Prev: <a class="el" href="lets_play.html">2. Let's Play</a> <br/>
 Next: <a class="el" href="design.html">4. Designing an Event-Driven Application</a></p>
<div class="image">
<img src="logo_ql_TM.jpg" alt="logo_ql_TM.jpg"/>
</div>
<p> Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.<br/>
 <a href="http://www.state-machine.com">http://www.state-machine.com</a> </p>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 30 2012 22:21:52 for QP/C by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>

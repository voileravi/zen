<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>QP/C: 9. Using Software Tracing for Testing and Debugging</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">QP/C Reference Manual</a>      </li>
      <li class="navelem"><a class="el" href="tutorial_page.html">QP/C Tutorial</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">9. Using Software Tracing for Testing and Debugging </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><em>This QP/C Tutorial is adapted from Chapter 1 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a><br/>
 by Miro Samek, the founder and president of Quantum Leaps, LLC.</em></p>
<div class="image">
<img src="qp_tutorial.jpg" alt="qp_tutorial.jpg"/>
</div>
<p>Prev: <a class="el" href="execution.html">8. Using the Built-in Real-Time Kernels and Third-Party RTOSes</a> <br/>
 Next: <a class="el" href="comparison.html">10. Comparison to the Traditional Approach</a></p>
<p>A running application built of active objects is a highly structured affair where all important system interactions funnel through the real-time framework (QF) and the state-machine engine (QEP). This offers a unique opportunity to use <b>software tracing</b> techniques to gain unprecedented insight into the entire system.</p>
<p>Software tracing is a method for obtaining diagnostic information in a live environment without the need to stop the application to get the system feedback. In a nutshell, software tracing is similar to peppering the code with <code>printf()</code> statements for logging and debugging, except that mature software tracing techniques are much less intrusive and more selective than the primitive <br/>
 printf().</p>
<p>Due to the inversion of a control, software tracing is particularly effective and powerful in combination with the event-driven frameworks. The QP event-driven platorm contains the sophisticated software tracing system called Quantum Spy (QS). The QS trace data can be thorough enough to produce complete sequence diagrams and detailed state machine activity for all state machines in the system. You can selectively monitor all event exchanges, event queues, event pools, and time events because all these elements are controlled by the framework. Additionally, if you use one of the kernels built into QP (the vanilla kernel or the preemptive QK kernel), you can obtain all the data available to a traditional RTOS as well, such as context switches and mutex activity</p>
<p>To show you how software tracing works in practice I present an example of a software tracing session. I use the application. All versions of the "Fly 'n'
Shoot" game contain the QS instrumentation. The tracing instrumentation becomes active when you build the "Spy" configuration.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>To build the "Spy" configuration in DOS version, please execute the <code>make.bat</code> script with the <code>spy</code> argument (<code>make</code> <code>spy</code>). To buld the "Spy" configuration in the ARM-Cortex version, please select the "Spy" configuration in the IAR EWARM IDE (see <a class="el" href="lets_play.html#F2s3">Figure 2-3</a>).</dd></dl>
<p><a class="el" href="tracing.html#F9s1">Figure 9-1</a> shows how to collect the software trace data from the DOS version of the "Fly 'n' Shoot" application, which is located in the directory &lt;qpc&gt;\examples\80x86\dos\watcom\l\dpp\spy\dpp.exe. You can re-build the "Spy" configuration by executing <code>make</code> <code>spy</code> from the command line. You need to run the <code>GAME.EXE</code> executable on a target PC with a serial port. You connect the serial port of the target machine to the serial port of a Windows or a Linux host workstation via a NULL-modem cable.</p>
<p><a class="anchor" id="F9s1"></a></p>
<div class="image">
<img src="Fig11.02.jpg" alt="Fig11.02.jpg"/>
<div class="caption">
Figure 9-1 Collecting software trace data from a 80x86 target.</div></div>
<p> Actually, all versions of "Fly 'n' Shoot" applications included in the standard QP distribution are instrumented for software tracing and I encourage you to try them all. For example, you can collect trace data from the LM3S811 board (see <a class="el" href="tracing.html#F9s2">Figure 9-2</a>). The LM3S811 board sends the QS trace data through the UART0 connected to the Virtual COM Port (VCP) provided by the USB debugger, so the QSPY host application can conveniently receive the trace data on the host PC. No additional serial cable is needed.</p>
<p><a class="anchor" id="F9s2"></a></p>
<div class="image">
<img src="Fig11.01.jpg" alt="Fig11.01.jpg"/>
<div class="caption">
Figure 9-2 Collecting software trace data from the LM3S811 board.</div></div>
<p> On the host workstation, you need to start the QSPY host application that decompresses and visualizes the QS trace data. The Windows executable of the QSPY host application is located in the directory &lt;qpc&gt;\tools\qspy\win32\vc2005\Release\qspy.exe. Assuming that this directory is your current directory, or is in your path, you invoke this console application by typing the following command at the command prompt:</p>
<div class="fragment"><pre class="fragment">qspy -c COM1 -b 115200
</pre></div><p>The first command-line parameter <code>-c COM1</code> tells the QSPY host application to receive the trace data from COM1. If your target is connected to a different COM port, you need to adjust the COM number. The second parameter configures the baud rate of the serial port to 115200. Section qspy_command explains the comman-line paratmeters of the QSPY host application.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>In the particular case of a Windows PC, you can use the same machine as the target and the host at the same time. You need to use a machine with two serial ports, which you connect with a NULL modem cable. You can use one serial port for the DPP target application running in a DOS-window and the other for the QSPY host application.</dd></dl>
<p>You might also use a Linux host machine. In case of Linux, you must first build the executable by running the <code>Makefile</code> located in the directory &lt;qpc&gt;/tools/qspy/linux/gnu/. You invoke the Linux executable by typing the following command at the command prompt:</p>
<div class="fragment"><pre class="fragment">qspy -c /dev/ttyS0 -b 115200
</pre></div><p>The first parameter <code>-c /dev/ttyS0</code> tells the QSPY application to receive the trace data from the ttyS0 serial device. If you connected a different serial port to the target, you need to adjust the ttyS number.</p>
<p>If everything is connected correctly, the QSPY host application should produce the human-readable output of the trace data to the screen. Please refer to qspy_page explains the human-readable format as well as importing the trace data to MATLAB&reg;.</p>
<p>Prev: <a class="el" href="execution.html">8. Using the Built-in Real-Time Kernels and Third-Party RTOSes</a> <br/>
 Next: <a class="el" href="comparison.html">10. Comparison to the Traditional Approach</a></p>
<div class="image">
<img src="logo_ql_TM.jpg" alt="logo_ql_TM.jpg"/>
<div class="caption">
Copyright &copy; 2002-2011 Quantum Leaps, LLC. All</div></div>
<p> Rights Reserved.<br/>
 <a href="http://www.state-machine.com">http://www.state-machine.com</a> </p>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 30 2012 22:21:52 for QP/C by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>

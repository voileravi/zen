<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>QP/C: qk.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">qk.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>QK/C platform-independent public interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="qequeue_8h_source.html">qequeue.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="qmpool_8h_source.html">qmpool.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="qpset_8h_source.html">qpset.h</a>&quot;</code><br/>
</div>
<p><a href="qk_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#aee19c1d6e860d59dda6e539852b99dbe">QF_EQUEUE_TYPE</a>&#160;&#160;&#160;<a class="el" href="struct_q_e_queue.html">QEQueue</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro defines the type of the event queue used for the active objects.  <a href="#aee19c1d6e860d59dda6e539852b99dbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#ae2426ed9b8543cbbccde98023d7773a7">QACTIVE_EQUEUE_WAIT_</a>(me_)&#160;&#160;&#160;<a class="el" href="qassert_8h.html#a41c3be2e4235ec0105fb56ca7d8ce10c">Q_ASSERT</a>((me_)-&gt;eQueue.frontEvt != (<a class="el" href="struct_q_event.html">QEvent</a> *)0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-dependent macro defining how QF should block the calling task when the QF native queue is empty.  <a href="#ae2426ed9b8543cbbccde98023d7773a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#ad4ad4a29e36b9ad8e2aff0e7074c2a68">QACTIVE_EQUEUE_SIGNAL_</a>(me_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-dependent macro defining how QF should signal the active object task that an event has just arrived.  <a href="#ad4ad4a29e36b9ad8e2aff0e7074c2a68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a61cb9dfde96112710d74f08620875427">QACTIVE_EQUEUE_ONEMPTY_</a>(me_)&#160;&#160;&#160;<a class="el" href="qpset_8h.html#a0b57e3951b29c13668f53c432adec4a3">QPSet64_remove</a>(&amp;QK_readySet_, (me_)-&gt;prio)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-dependent macro defining the action QF should take when the native QF event queue becomes empty.  <a href="#a61cb9dfde96112710d74f08620875427"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#ab786be96ee118929bfb4dcd51d3acce5">QF_EPOOL_TYPE_</a>&#160;&#160;&#160;<a class="el" href="struct_q_m_pool.html">QMPool</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro defines the type of the event pool used in this QF port.  <a href="#ab786be96ee118929bfb4dcd51d3acce5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#af536ec576d2f03b68bcf38ca0c8b918d">QF_EPOOL_INIT_</a>(p_, poolSto_, poolSize_, evtSize_)&#160;&#160;&#160;<a class="el" href="qmp__init_8c.html#aa302b94344244dd5ec650e4a2dc8f11f">QMPool_init</a>(&amp;(p_), (poolSto_), (poolSize_), (QMPoolSize)(evtSize_))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-dependent macro defining the event pool initialization.  <a href="#af536ec576d2f03b68bcf38ca0c8b918d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a920e9b4f47e69079a12bf79a3c43a058">QF_EPOOL_EVENT_SIZE_</a>(p_)&#160;&#160;&#160;((QEventSize)(p_).blockSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-dependent macro defining how QF should obtain the event pool block-size.  <a href="#a920e9b4f47e69079a12bf79a3c43a058"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#abb96d6c572a8d24921a1aa2cbddfea8c">QF_EPOOL_GET_</a>(p_, e_)&#160;&#160;&#160;((e_) = (<a class="el" href="struct_q_event.html">QEvent</a> *)<a class="el" href="qmp__get_8c.html#afd3eda95b1faeb2b064bcd1a76ee78fb">QMPool_get</a>(&amp;(p_)))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-dependent macro defining how QF should obtain an event <em>e_</em> from the event pool <em>p_</em>.  <a href="#abb96d6c572a8d24921a1aa2cbddfea8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#ac34ffaba95ab38473684fdfeaef17d9a">QF_EPOOL_PUT_</a>(p_, e_)&#160;&#160;&#160;(<a class="el" href="qmp__put_8c.html#acfc6c41213e5848fa33feef1d90d47ba">QMPool_put</a>(&amp;(p_), (e_)))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-dependent macro defining how QF should return an event <em>e_</em> to the event pool <em>p_</em>.  <a href="#ac34ffaba95ab38473684fdfeaef17d9a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104">QMutex</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">QK Mutex type.  <a href="#a13b8c3b1b8a65b6e521505922f643104"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#afaccffd06f0f9786a7492b5ffbb3d89c">QK_sched_</a> (uint8_t p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">QK scheduler.  <a href="#afaccffd06f0f9786a7492b5ffbb3d89c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#af8b914cdf0c91cf11e02e73f184d6bb3">QK_schedExt_</a> (uint8_t p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">QK extended scheduler.  <a href="#af8b914cdf0c91cf11e02e73f184d6bb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a91169080a96934668fa3aea0fa2050e9">QK_schedPrio_</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the highest-priority task ready to run.  <a href="#a91169080a96934668fa3aea0fa2050e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#ae1fa4705c311e29699a0164a20362bf1">QK_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">QK initialization.  <a href="#ae1fa4705c311e29699a0164a20362bf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a667daad24b172e782fe4e2b5b06fbf61">QK_onIdle</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">QK idle callback (customized in BSPs for QK)  <a href="#a667daad24b172e782fe4e2b5b06fbf61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="qevent_8h.html#a40bb5262bf908c328fbcfbe5d29d0201">char_t</a> const Q_ROM *Q_ROM_VAR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a4fe0b802eee744c06de88e4d30b59149">QK_getVersion</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get the current QK version number string  <a href="#a4fe0b802eee744c06de88e4d30b59149"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104">QMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a02a27011a5aa955b140cd749b64b16e2">QK_mutexLock</a> (uint8_t prioCeiling)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">QK priority-ceiling mutex lock.  <a href="#a02a27011a5aa955b140cd749b64b16e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a9f4ddf313bcfd3cac43225f2a35e278a">QK_mutexUnlock</a> (<a class="el" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104">QMutex</a> mutex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">QK priority-ceiling mutex unlock.  <a href="#a9f4ddf313bcfd3cac43225f2a35e278a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#af46a744fbc31d3f15949e663684ce10d">QK_currPrio_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#ab868f80a04fc4ddb6b3fd8c1ecf9ad9a">QK_intNest_</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>QK/C platform-independent public interface. </p>
<p>This header file must be included directly or indirectly in all modules (*.c files) that use QK/C. </p>

<p>Definition in file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a61cb9dfde96112710d74f08620875427"></a><!-- doxytag: member="qk.h::QACTIVE_EQUEUE_ONEMPTY_" ref="a61cb9dfde96112710d74f08620875427" args="(me_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="qk_8h.html#a61cb9dfde96112710d74f08620875427">QACTIVE_EQUEUE_ONEMPTY_</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">me_</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="qpset_8h.html#a0b57e3951b29c13668f53c432adec4a3">QPSet64_remove</a>(&amp;QK_readySet_, (me_)-&gt;prio)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Platform-dependent macro defining the action QF should take when the native QF event queue becomes empty. </p>
<p>The macro is necessary only when the native QF event queue is used. The signaling of task involves unblocking the task if it is blocked.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>QACTIVE_EQUEUE_ONEMPTY_ is called from a critical section. It should not leave the critical section.</dd>
<dd>
This is just an example of QACTIVE_EQUEUE_ONEMPTY_ for the QK-port of QF. In other QF ports you need to define the macro appropriately for the underlying kernel/OS you're using. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00154">154</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qa__get___8c_source.html#l00043">QActive_get_()</a>.</p>

</div>
</div>
<a class="anchor" id="ad4ad4a29e36b9ad8e2aff0e7074c2a68"></a><!-- doxytag: member="qk.h::QACTIVE_EQUEUE_SIGNAL_" ref="ad4ad4a29e36b9ad8e2aff0e7074c2a68" args="(me_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="qk_8h.html#ad4ad4a29e36b9ad8e2aff0e7074c2a68">QACTIVE_EQUEUE_SIGNAL_</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">me_</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> { \
        QPSet64_insert(&amp;QK_readySet_, (me_)-&gt;prio); \
        if (<a class="code" href="qk_8h.html#ab868f80a04fc4ddb6b3fd8c1ecf9ad9a">QK_intNest_</a> == (uint8_t)0) { \
            uint8_t p = <a class="code" href="qk_8h.html#a91169080a96934668fa3aea0fa2050e9" title="Find the highest-priority task ready to run.">QK_schedPrio_</a>(); \
            if (p != (uint8_t)0) { \
                QK_sched_(p); \
            } \
        } \
    } <span class="keywordflow">while</span> (0)
</pre></div>
<p>Platform-dependent macro defining how QF should signal the active object task that an event has just arrived. </p>
<p>The macro is necessary only when the native QF event queue is used. The signaling of task involves unblocking the task if it is blocked.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>QACTIVE_EQUEUE_SIGNAL_ is called from a critical section. It might leave the critical section internally, but must restore the critical section before exiting to the caller.</dd>
<dd>
This is just an example of QACTIVE_EQUEUE_SIGNAL_ for the QK-port of QF. In other QF ports you need to define the macro appropriately for the underlying kernel/OS you're using. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00131">131</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qa__fifo_8c_source.html#l00046">QActive_postFIFO()</a>, and <a class="el" href="qa__lifo_8c_source.html#l00043">QActive_postLIFO()</a>.</p>

</div>
</div>
<a class="anchor" id="ae2426ed9b8543cbbccde98023d7773a7"></a><!-- doxytag: member="qk.h::QACTIVE_EQUEUE_WAIT_" ref="ae2426ed9b8543cbbccde98023d7773a7" args="(me_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="qk_8h.html#ae2426ed9b8543cbbccde98023d7773a7">QACTIVE_EQUEUE_WAIT_</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">me_</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="qassert_8h.html#a41c3be2e4235ec0105fb56ca7d8ce10c">Q_ASSERT</a>((me_)-&gt;eQueue.frontEvt != (<a class="el" href="struct_q_event.html">QEvent</a> *)0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Platform-dependent macro defining how QF should block the calling task when the QF native queue is empty. </p>
<p>QK ready-set of active objects </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of QACTIVE_EQUEUE_WAIT_ for the QK-port of QF. QK never activates a task that has no events to process, so in this case the macro asserts that the queue is not empty. In other QF ports you need to define the macro appropriately for the underlying kernel/OS you're using. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00100">100</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qa__get___8c_source.html#l00043">QActive_get_()</a>.</p>

</div>
</div>
<a class="anchor" id="a920e9b4f47e69079a12bf79a3c43a058"></a><!-- doxytag: member="qk.h::QF_EPOOL_EVENT_SIZE_" ref="a920e9b4f47e69079a12bf79a3c43a058" args="(p_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="qk_8h.html#a920e9b4f47e69079a12bf79a3c43a058">QF_EPOOL_EVENT_SIZE_</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p_</td><td>)</td>
          <td>&#160;&#160;&#160;((QEventSize)(p_).blockSize)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Platform-dependent macro defining how QF should obtain the event pool block-size. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of QF_EPOOL_EVENT_SIZE_ for the QK-port of QF. In other QF ports you need to define the macro appropriately for the underlying kernel/OS you're using. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00186">186</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qf__new_8c_source.html#l00040">QF_new_()</a>, and <a class="el" href="qf__pool_8c_source.html#l00044">QF_poolInit()</a>.</p>

</div>
</div>
<a class="anchor" id="abb96d6c572a8d24921a1aa2cbddfea8c"></a><!-- doxytag: member="qk.h::QF_EPOOL_GET_" ref="abb96d6c572a8d24921a1aa2cbddfea8c" args="(p_, e_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="qk_8h.html#abb96d6c572a8d24921a1aa2cbddfea8c">QF_EPOOL_GET_</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((e_) = (<a class="el" href="struct_q_event.html">QEvent</a> *)<a class="el" href="qmp__get_8c.html#afd3eda95b1faeb2b064bcd1a76ee78fb">QMPool_get</a>(&amp;(p_)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Platform-dependent macro defining how QF should obtain an event <em>e_</em> from the event pool <em>p_</em>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of QF_EPOOL_GET_ for the QK-port of QF. In other QF ports you need to define the macro appropriately for the underlying kernel/OS you're using. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00195">195</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qf__new_8c_source.html#l00040">QF_new_()</a>.</p>

</div>
</div>
<a class="anchor" id="af536ec576d2f03b68bcf38ca0c8b918d"></a><!-- doxytag: member="qk.h::QF_EPOOL_INIT_" ref="af536ec576d2f03b68bcf38ca0c8b918d" args="(p_, poolSto_, poolSize_, evtSize_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="qk_8h.html#af536ec576d2f03b68bcf38ca0c8b918d">QF_EPOOL_INIT_</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">poolSto_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">poolSize_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">evtSize_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="qmp__init_8c.html#aa302b94344244dd5ec650e4a2dc8f11f">QMPool_init</a>(&amp;(p_), (poolSto_), (poolSize_), (QMPoolSize)(evtSize_))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Platform-dependent macro defining the event pool initialization. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of QF_EPOOL_INIT_ for the QK-port of QF. In other QF ports you need to define the macro appropriately for the underlying kernel/OS you're using. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00176">176</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qf__pool_8c_source.html#l00044">QF_poolInit()</a>.</p>

</div>
</div>
<a class="anchor" id="ac34ffaba95ab38473684fdfeaef17d9a"></a><!-- doxytag: member="qk.h::QF_EPOOL_PUT_" ref="ac34ffaba95ab38473684fdfeaef17d9a" args="(p_, e_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="qk_8h.html#ac34ffaba95ab38473684fdfeaef17d9a">QF_EPOOL_PUT_</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(<a class="el" href="qmp__put_8c.html#acfc6c41213e5848fa33feef1d90d47ba">QMPool_put</a>(&amp;(p_), (e_)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Platform-dependent macro defining how QF should return an event <em>e_</em> to the event pool <em>p_</em>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of QF_EPOOL_PUT_ for the QK-port of QF. In other QF ports you need to define the macro appropriately for the underlying kernel/OS you're using. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00204">204</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qf__gc_8c_source.html#l00040">QF_gc()</a>.</p>

</div>
</div>
<a class="anchor" id="ab786be96ee118929bfb4dcd51d3acce5"></a><!-- doxytag: member="qk.h::QF_EPOOL_TYPE_" ref="ab786be96ee118929bfb4dcd51d3acce5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="qk_8h.html#ab786be96ee118929bfb4dcd51d3acce5">QF_EPOOL_TYPE_</a>&#160;&#160;&#160;<a class="el" href="struct_q_m_pool.html">QMPool</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This macro defines the type of the event pool used in this QF port. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of the macro definition. Typically, you need to define it in the specific QF port file (<a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C compiler.">qf_port.h</a>). In case of QK, which always depends on the native QF memory pool, this macro is defined at the level of the platform-independent interface <a class="el" href="qk_8h.html" title="QK/C platform-independent public interface.">qk.h</a>. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00168">168</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

</div>
</div>
<a class="anchor" id="aee19c1d6e860d59dda6e539852b99dbe"></a><!-- doxytag: member="qk.h::QF_EQUEUE_TYPE" ref="aee19c1d6e860d59dda6e539852b99dbe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="qk_8h.html#aee19c1d6e860d59dda6e539852b99dbe">QF_EQUEUE_TYPE</a>&#160;&#160;&#160;<a class="el" href="struct_q_e_queue.html">QEQueue</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This macro defines the type of the event queue used for the active objects. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of the macro definition. Typically, you need to define it in the specific QF port file (<a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C compiler.">qf_port.h</a>). In case of QK, which always depends on the native QF queue, this macro is defined at the level of the platform-independent interface <a class="el" href="qk_8h.html" title="QK/C platform-independent public interface.">qk.h</a>. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00055">55</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a13b8c3b1b8a65b6e521505922f643104"></a><!-- doxytag: member="qk.h::QMutex" ref="a13b8c3b1b8a65b6e521505922f643104" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t <a class="el" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104">QMutex</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>QK Mutex type. </p>
<p>QMutex represents the priority-ceiling mutex available in QK. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qk_8h.html#a02a27011a5aa955b140cd749b64b16e2" title="QK priority-ceiling mutex lock.">QK_mutexLock()</a> </dd>
<dd>
<a class="el" href="qk_8h.html#a9f4ddf313bcfd3cac43225f2a35e278a" title="QK priority-ceiling mutex unlock.">QK_mutexUnlock()</a> </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00273">273</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a4fe0b802eee744c06de88e4d30b59149"></a><!-- doxytag: member="qk.h::QK_getVersion" ref="a4fe0b802eee744c06de88e4d30b59149" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qevent_8h.html#a40bb5262bf908c328fbcfbe5d29d0201">char_t</a> const Q_ROM* Q_ROM_VAR <a class="el" href="qk_8c.html#a4fe0b802eee744c06de88e4d30b59149">QK_getVersion</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get the current QK version number string </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>version of the QK as a constant 6-character string of the form x.y.zz, where x is a 1-digit major version number, y is a 1-digit minor version number, and zz is a 2-digit release number.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>QK_getPortVersion() </dd></dl>

<p>Definition at line <a class="el" href="qk_8c_source.html#l00052">52</a> of file <a class="el" href="qk_8c_source.html">qk.c</a>.</p>

<p>References <a class="el" href="qf__act_8c_source.html#l00045">QF_getVersion()</a>.</p>

</div>
</div>
<a class="anchor" id="ae1fa4705c311e29699a0164a20362bf1"></a><!-- doxytag: member="qk.h::QK_init" ref="ae1fa4705c311e29699a0164a20362bf1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qk_8h.html#ae1fa4705c311e29699a0164a20362bf1">QK_init</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>QK initialization. </p>
<p><a class="el" href="qk_8h.html#ae1fa4705c311e29699a0164a20362bf1" title="QK initialization.">QK_init()</a> is called from <a class="el" href="qf_8h.html#adac7eccb860d910c4e446d3143798bba" title="QF initialization.">QF_init()</a> in <a class="el" href="qk_8c.html" title="QK_readySet_, QK_currPrio_, and QK_intNest_ definitions and QK_getVersion(), QF_init(), QF_run(), QF_stop(), QActive_start(), QActive_stop(), QK_schedPrio_() implementations.">qk.c</a>. This function is defined in the QK ports. </p>

<p>Referenced by <a class="el" href="qk_8c_source.html#l00056">QF_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a02a27011a5aa955b140cd749b64b16e2"></a><!-- doxytag: member="qk.h::QK_mutexLock" ref="a02a27011a5aa955b140cd749b64b16e2" args="(uint8_t prioCeiling)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104">QMutex</a> <a class="el" href="qk__mutex_8c.html#a02a27011a5aa955b140cd749b64b16e2">QK_mutexLock</a> </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>prioCeiling</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>QK priority-ceiling mutex lock. </p>
<p>Lock the QK scheduler up to the priority level <em>prioCeiling</em>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function should be always paired with <a class="el" href="qk_8h.html#a9f4ddf313bcfd3cac43225f2a35e278a" title="QK priority-ceiling mutex unlock.">QK_mutexUnlock()</a>. The code between <a class="el" href="qk_8h.html#a02a27011a5aa955b140cd749b64b16e2" title="QK priority-ceiling mutex lock.">QK_mutexLock()</a> and <a class="el" href="qk_8h.html#a9f4ddf313bcfd3cac43225f2a35e278a" title="QK priority-ceiling mutex unlock.">QK_mutexUnlock()</a> should be kept to the minimum.</dd></dl>
<div class="fragment"><pre class="fragment">    <a class="code" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104" title="QK Mutex type.">QMutex</a> mux;
    . . .
    mux = <a class="code" href="qk_8h.html#a02a27011a5aa955b140cd749b64b16e2" title="QK priority-ceiling mutex lock.">QK_mutexLock</a>(PRIO_CEILING);

    <span class="comment">/* access the shared resource */</span>

    <a class="code" href="qk_8h.html#a9f4ddf313bcfd3cac43225f2a35e278a" title="QK priority-ceiling mutex unlock.">QK_mutexUnlock</a>(mux);

    . . . 
</pre></div> 
<p>Definition at line <a class="el" href="qk__mutex_8c_source.html#l00047">47</a> of file <a class="el" href="qk__mutex_8c_source.html">qk_mutex.c</a>.</p>

<p>References <a class="el" href="qk__mutex_8c_source.html#l00044">QK_ceilingPrio_</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00108">QS_QK_MUTEX_LOCK</a>, <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>, and <a class="el" href="qs_8h_source.html#l00753">QS_U8_</a>.</p>

</div>
</div>
<a class="anchor" id="a9f4ddf313bcfd3cac43225f2a35e278a"></a><!-- doxytag: member="qk.h::QK_mutexUnlock" ref="a9f4ddf313bcfd3cac43225f2a35e278a" args="(QMutex mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qk__mutex_8c.html#a9f4ddf313bcfd3cac43225f2a35e278a">QK_mutexUnlock</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104">QMutex</a>&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>QK priority-ceiling mutex unlock. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function should be always paired with <a class="el" href="qk_8h.html#a02a27011a5aa955b140cd749b64b16e2" title="QK priority-ceiling mutex lock.">QK_mutexLock()</a>. The code between <a class="el" href="qk_8h.html#a02a27011a5aa955b140cd749b64b16e2" title="QK priority-ceiling mutex lock.">QK_mutexLock()</a> and <a class="el" href="qk_8h.html#a9f4ddf313bcfd3cac43225f2a35e278a" title="QK priority-ceiling mutex unlock.">QK_mutexUnlock()</a> should be kept to the minimum.</dd></dl>
<div class="fragment"><pre class="fragment">    <a class="code" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104" title="QK Mutex type.">QMutex</a> mux;
    . . .
    mux = <a class="code" href="qk_8h.html#a02a27011a5aa955b140cd749b64b16e2" title="QK priority-ceiling mutex lock.">QK_mutexLock</a>(PRIO_CEILING);

    <span class="comment">/* access the shared resource */</span>

    <a class="code" href="qk_8h.html#a9f4ddf313bcfd3cac43225f2a35e278a" title="QK priority-ceiling mutex unlock.">QK_mutexUnlock</a>(mux);

    . . . 
</pre></div> 
<p>Definition at line <a class="el" href="qk__mutex_8c_source.html#l00066">66</a> of file <a class="el" href="qk__mutex_8c_source.html">qk_mutex.c</a>.</p>

<p>References <a class="el" href="qk__mutex_8c_source.html#l00044">QK_ceilingPrio_</a>, <a class="el" href="qk__sched_8c_source.html#l00041">QK_sched_()</a>, <a class="el" href="qk_8c_source.html#l00114">QK_schedPrio_()</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00109">QS_QK_MUTEX_UNLOCK</a>, <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>, and <a class="el" href="qs_8h_source.html#l00753">QS_U8_</a>.</p>

</div>
</div>
<a class="anchor" id="a667daad24b172e782fe4e2b5b06fbf61"></a><!-- doxytag: member="qk.h::QK_onIdle" ref="a667daad24b172e782fe4e2b5b06fbf61" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qk_8h.html#a667daad24b172e782fe4e2b5b06fbf61">QK_onIdle</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>QK idle callback (customized in BSPs for QK) </p>
<p><a class="el" href="qk_8h.html#a667daad24b172e782fe4e2b5b06fbf61" title="QK idle callback (customized in BSPs for QK)">QK_onIdle()</a> is called continously by the QK idle loop. This callback gives the application an opportunity to enter a power-saving CPU mode, or perform some other idle processing.</p>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="qk_8h.html#a667daad24b172e782fe4e2b5b06fbf61" title="QK idle callback (customized in BSPs for QK)">QK_onIdle()</a> is invoked with interrupts unlocked and must also return with interrupts unlocked.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#afcac91c9d71d70255fdd88db3fb16e24" title="QF idle callback (customized in BSPs for QF)">QF_onIdle()</a> </dd></dl>

<p>Referenced by <a class="el" href="qk_8c_source.html#l00075">QF_run()</a>.</p>

</div>
</div>
<a class="anchor" id="afaccffd06f0f9786a7492b5ffbb3d89c"></a><!-- doxytag: member="qk.h::QK_sched_" ref="afaccffd06f0f9786a7492b5ffbb3d89c" args="(uint8_t p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qk__sched_8c.html#afaccffd06f0f9786a7492b5ffbb3d89c">QK_sched_</a> </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>QK scheduler. </p>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="qk_8h.html#afaccffd06f0f9786a7492b5ffbb3d89c" title="QK scheduler.">QK_sched_()</a> must be always called with interrupts locked. The scheduler might unlock the interrupts internally, but always returns with interrupts locked. </dd></dl>

<p>Definition at line <a class="el" href="qk__sched_8c_source.html#l00041">41</a> of file <a class="el" href="qk__sched_8c_source.html">qk_sched.c</a>.</p>

<p>References <a class="el" href="qa__get___8c_source.html#l00043">QActive_get_()</a>, <a class="el" href="qf__act_8c_source.html#l00041">QF_active_</a>, <a class="el" href="qf__gc_8c_source.html#l00040">QF_gc()</a>, <a class="el" href="qf__port_8h_source.html#l00182">QF_INT_DISABLE</a>, <a class="el" href="qf__port_8h_source.html#l00192">QF_INT_ENABLE</a>, <a class="el" href="qk_8c_source.html#l00048">QK_currPrio_</a>, <a class="el" href="qk__port_8h_source.html#l00080">QK_TLS</a>, <a class="el" href="qpset_8h_source.html#l00162">QPSet64_findMax</a>, <a class="el" href="qpset_8h_source.html#l00081">QPSet8_findMax</a>, <a class="el" href="qs___8c_source.html#l00038">QS_aoObj_</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00110">QS_QK_SCHEDULE</a>, <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>, <a class="el" href="qs_8h_source.html#l00753">QS_U8_</a>, and <a class="el" href="qf_8h_source.html#l00144">QActive::super</a>.</p>

<p>Referenced by <a class="el" href="qk__mutex_8c_source.html#l00066">QK_mutexUnlock()</a>.</p>

</div>
</div>
<a class="anchor" id="af8b914cdf0c91cf11e02e73f184d6bb3"></a><!-- doxytag: member="qk.h::QK_schedExt_" ref="af8b914cdf0c91cf11e02e73f184d6bb3" args="(uint8_t p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qk__ext_8c.html#af8b914cdf0c91cf11e02e73f184d6bb3">QK_schedExt_</a> </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>QK extended scheduler. </p>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="qk_8h.html#af8b914cdf0c91cf11e02e73f184d6bb3" title="QK extended scheduler.">QK_schedExt_()</a> must be always called with interrupts locked. The scheduler might unlock the interrupts internally, but always returns with interrupts locked. </dd></dl>

<p>Definition at line <a class="el" href="qk__ext_8c_source.html#l00041">41</a> of file <a class="el" href="qk__ext_8c_source.html">qk_ext.c</a>.</p>

<p>References <a class="el" href="qa__get___8c_source.html#l00043">QActive_get_()</a>, <a class="el" href="qf__act_8c_source.html#l00041">QF_active_</a>, <a class="el" href="qf__gc_8c_source.html#l00040">QF_gc()</a>, <a class="el" href="qf__port_8h_source.html#l00182">QF_INT_DISABLE</a>, <a class="el" href="qf__port_8h_source.html#l00192">QF_INT_ENABLE</a>, <a class="el" href="qk_8c_source.html#l00048">QK_currPrio_</a>, <a class="el" href="qk__port_8h_source.html#l00050">QK_EXT_SAVE</a>, <a class="el" href="qk__port_8h_source.html#l00080">QK_TLS</a>, <a class="el" href="qpset_8h_source.html#l00162">QPSet64_findMax</a>, <a class="el" href="qpset_8h_source.html#l00081">QPSet8_findMax</a>, <a class="el" href="qs___8c_source.html#l00038">QS_aoObj_</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00110">QS_QK_SCHEDULE</a>, <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>, <a class="el" href="qs_8h_source.html#l00753">QS_U8_</a>, and <a class="el" href="qf_8h_source.html#l00144">QActive::super</a>.</p>

</div>
</div>
<a class="anchor" id="a91169080a96934668fa3aea0fa2050e9"></a><!-- doxytag: member="qk.h::QK_schedPrio_" ref="a91169080a96934668fa3aea0fa2050e9" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="qk_8c.html#a91169080a96934668fa3aea0fa2050e9">QK_schedPrio_</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the highest-priority task ready to run. </p>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="qk_8h.html#a91169080a96934668fa3aea0fa2050e9" title="Find the highest-priority task ready to run.">QK_schedPrio_()</a> must be always called with interrupts locked and returns with interrupts locked. </dd></dl>

<p>Definition at line <a class="el" href="qk_8c_source.html#l00114">114</a> of file <a class="el" href="qk_8c_source.html">qk.c</a>.</p>

<p>References <a class="el" href="qk__mutex_8c_source.html#l00044">QK_ceilingPrio_</a>, <a class="el" href="qpset_8h_source.html#l00162">QPSet64_findMax</a>, and <a class="el" href="qpset_8h_source.html#l00081">QPSet8_findMax</a>.</p>

<p>Referenced by <a class="el" href="qk__mutex_8c_source.html#l00066">QK_mutexUnlock()</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="af46a744fbc31d3f15949e663684ce10d"></a><!-- doxytag: member="qk.h::QK_currPrio_" ref="af46a744fbc31d3f15949e663684ce10d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="qk_8c.html#af46a744fbc31d3f15949e663684ce10d">QK_currPrio_</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>current task/interrupt priority </p>

<p>Definition at line <a class="el" href="qk_8c_source.html#l00048">48</a> of file <a class="el" href="qk_8c_source.html">qk.c</a>.</p>

<p>Referenced by <a class="el" href="qk__sched_8c_source.html#l00041">QK_sched_()</a>, and <a class="el" href="qk__ext_8c_source.html#l00041">QK_schedExt_()</a>.</p>

</div>
</div>
<a class="anchor" id="ab868f80a04fc4ddb6b3fd8c1ecf9ad9a"></a><!-- doxytag: member="qk.h::QK_intNest_" ref="ab868f80a04fc4ddb6b3fd8c1ecf9ad9a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="qk_8c.html#ab868f80a04fc4ddb6b3fd8c1ecf9ad9a">QK_intNest_</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>interrupt nesting level </p>

<p>Definition at line <a class="el" href="qk_8c_source.html#l00049">49</a> of file <a class="el" href="qk_8c_source.html">qk.c</a>.</p>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 30 2012 22:21:51 for QP/C by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>

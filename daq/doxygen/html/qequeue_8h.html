<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>QP/C: qequeue.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">qequeue.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>platform-independent event queue interface.  
<a href="#details">More...</a></p>

<p><a href="qequeue_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_e_queue.html">QEQueue</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Native QF Event Queue.  <a href="struct_q_e_queue.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qequeue_8h.html#a54463011114f6b076e0bd62e3fa27102">QF_EQUEUE_CTR_SIZE</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The size (in bytes) of the ring-buffer counters used in the native QF event queue implementation. Valid values: 1, 2, or 4; default 1.  <a href="#a54463011114f6b076e0bd62e3fa27102"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qequeue_8h.html#a1559cc07b69d811deb906f65f376b9d8">QEQueue_getNFree</a>(me_)&#160;&#160;&#160;((me_)-&gt;nFree)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"raw" thread-safe QF event queue operation for obtaining the number of free entries still available in the queue.  <a href="#a1559cc07b69d811deb906f65f376b9d8"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qequeue_8h.html#a3a5e050cce0e5fa8b5a87a788ef699ac">QEQueueCtr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The data type to store the ring-buffer counters based on the macro <a class="el" href="qequeue_8h.html#a54463011114f6b076e0bd62e3fa27102" title="The size (in bytes) of the ring-buffer counters used in the native QF event queue implementation...">QF_EQUEUE_CTR_SIZE</a>.  <a href="#a3a5e050cce0e5fa8b5a87a788ef699ac"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qequeue_8h.html#abec6b357b489b637afc622b6ee635921">QEQueue_init</a> (<a class="el" href="struct_q_e_queue.html">QEQueue</a> *me, <a class="el" href="struct_q_event.html">QEvent</a> const *qSto[], <a class="el" href="qequeue_8h.html#a3a5e050cce0e5fa8b5a87a788ef699ac">QEQueueCtr</a> qLen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the native QF event queue.  <a href="#abec6b357b489b637afc622b6ee635921"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qequeue_8h.html#a1432f9632a6f30c434aea96cc20aa2cf">QEQueue_postFIFO</a> (<a class="el" href="struct_q_e_queue.html">QEQueue</a> *me, <a class="el" href="struct_q_event.html">QEvent</a> const *e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"raw" thread-safe QF event queue implementation for the First-In-First-Out (FIFO) event posting. You can call this function from any task context or ISR context. Please note that this function uses internally a critical section.  <a href="#a1432f9632a6f30c434aea96cc20aa2cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qequeue_8h.html#a8ea2e15922ce2e213aa0c27e72cd730a">QEQueue_postLIFO</a> (<a class="el" href="struct_q_e_queue.html">QEQueue</a> *me, <a class="el" href="struct_q_event.html">QEvent</a> const *e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"raw" thread-safe QF event queue implementation for the Last-In-First-Out (LIFO) event posting.  <a href="#a8ea2e15922ce2e213aa0c27e72cd730a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qequeue_8h.html#ae5d5b1feb038085e2922e2f4e45b48a0">QEQueue_get</a> (<a class="el" href="struct_q_e_queue.html">QEQueue</a> *me)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"raw" thread-safe QF event queue implementation for the event get operation.  <a href="#ae5d5b1feb038085e2922e2f4e45b48a0"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>platform-independent event queue interface. </p>
<p>This header file must be included in all QF ports that use native QF event queue implementation. Also, this file is needed when the "raw" thread-safe queues are used for communication between active objects and non-framework entities, such as ISRs, device drivers, or legacy code. </p>

<p>Definition in file <a class="el" href="qequeue_8h_source.html">qequeue.h</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a1559cc07b69d811deb906f65f376b9d8"></a><!-- doxytag: member="qequeue.h::QEQueue_getNFree" ref="a1559cc07b69d811deb906f65f376b9d8" args="(me_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="qequeue_8h.html#a1559cc07b69d811deb906f65f376b9d8">QEQueue_getNFree</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">me_</td><td>)</td>
          <td>&#160;&#160;&#160;((me_)-&gt;nFree)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"raw" thread-safe QF event queue operation for obtaining the number of free entries still available in the queue. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operation needs to be used with caution because the number of free entries can change unexpectedly. The main intent for using this operation is in conjunction with event deferral. In this case the queue is accessed only from a single thread (by a single AO), so the number of free entries cannot change unexpectedly.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#a58236a7032392f585a03122c134fec1b" title="Defer an event to a given separate event queue.">QActive_defer()</a>, <a class="el" href="qf_8h.html#a352e707faee76e5cfd6c170a47c24fc3" title="Recall a deferred event from a given event queue.">QActive_recall()</a> </dd></dl>

<p>Definition at line <a class="el" href="qequeue_8h_source.html#l00222">222</a> of file <a class="el" href="qequeue_8h_source.html">qequeue.h</a>.</p>

</div>
</div>
<a class="anchor" id="a54463011114f6b076e0bd62e3fa27102"></a><!-- doxytag: member="qequeue.h::QF_EQUEUE_CTR_SIZE" ref="a54463011114f6b076e0bd62e3fa27102" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="qequeue_8h.html#a54463011114f6b076e0bd62e3fa27102">QF_EQUEUE_CTR_SIZE</a>&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The size (in bytes) of the ring-buffer counters used in the native QF event queue implementation. Valid values: 1, 2, or 4; default 1. </p>
<p>This macro can be defined in the QF port file (<a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C compiler.">qf_port.h</a>) to configure the <a class="el" href="qequeue_8h.html#a3a5e050cce0e5fa8b5a87a788ef699ac" title="The data type to store the ring-buffer counters based on the macro QF_EQUEUE_CTR_SIZE.">QEQueueCtr</a> type. Here the macro is not defined so the default of 1 byte is chosen. </p>

<p>Definition at line <a class="el" href="qequeue_8h_source.html#l00053">53</a> of file <a class="el" href="qequeue_8h_source.html">qequeue.h</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a3a5e050cce0e5fa8b5a87a788ef699ac"></a><!-- doxytag: member="qequeue.h::QEQueueCtr" ref="a3a5e050cce0e5fa8b5a87a788ef699ac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t <a class="el" href="qequeue_8h.html#a3a5e050cce0e5fa8b5a87a788ef699ac">QEQueueCtr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The data type to store the ring-buffer counters based on the macro <a class="el" href="qequeue_8h.html#a54463011114f6b076e0bd62e3fa27102" title="The size (in bytes) of the ring-buffer counters used in the native QF event queue implementation...">QF_EQUEUE_CTR_SIZE</a>. </p>
<p>The dynamic range of this data type determines the maximum length of the ring buffer managed by the native QF event queue. </p>

<p>Definition at line <a class="el" href="qequeue_8h_source.html#l00063">63</a> of file <a class="el" href="qequeue_8h_source.html">qequeue.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ae5d5b1feb038085e2922e2f4e45b48a0"></a><!-- doxytag: member="qequeue.h::QEQueue_get" ref="ae5d5b1feb038085e2922e2f4e45b48a0" args="(QEQueue *me)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_event.html">QEvent</a> const* <a class="el" href="qeq__get_8c.html#ae5d5b1feb038085e2922e2f4e45b48a0">QEQueue_get</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_e_queue.html">QEQueue</a> *&#160;</td>
          <td class="paramname"><em>me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"raw" thread-safe QF event queue implementation for the event get operation. </p>
<p>If the queue has one or more events, the function returns the event at the front of the queue, otherwise it returns NULL. You can call this function from any task context or ISR context. Please note that this function uses internally a critical section.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qequeue_8h.html#a1432f9632a6f30c434aea96cc20aa2cf" title="&quot;raw&quot; thread-safe QF event queue implementation for the First-In-First-Out (FIFO) event posting...">QEQueue_postFIFO()</a>, <a class="el" href="qequeue_8h.html#a8ea2e15922ce2e213aa0c27e72cd730a" title="&quot;raw&quot; thread-safe QF event queue implementation for the Last-In-First-Out (LIFO) event posting...">QEQueue_postLIFO()</a> </dd></dl>

<p>Definition at line <a class="el" href="qeq__get_8c_source.html#l00041">41</a> of file <a class="el" href="qeq__get_8c_source.html">qeq_get.c</a>.</p>

<p>References <a class="el" href="qequeue_8h_source.html#l00137">QEQueue::end</a>, <a class="el" href="qequeue_8h_source.html#l00128">QEQueue::frontEvt</a>, <a class="el" href="qequeue_8h_source.html#l00149">QEQueue::nFree</a>, <a class="el" href="qf__pkg_8h_source.html#l00097">QF_EVT_POOL_ID_</a>, <a class="el" href="qf__pkg_8h_source.html#l00100">QF_EVT_REF_CTR_</a>, <a class="el" href="qf__pkg_8h_source.html#l00109">QF_PTR_AT_</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qf__pkg_8h_source.html#l00124">QS_EQC_</a>, <a class="el" href="qs___8c_source.html#l00040">QS_eqObj_</a>, <a class="el" href="qs_8h_source.html#l00777">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00077">QS_QF_EQUEUE_GET</a>, <a class="el" href="qs_8h_source.html#l00078">QS_QF_EQUEUE_GET_LAST</a>, <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>, <a class="el" href="qs_8h_source.html#l00753">QS_U8_</a>, <a class="el" href="qequeue_8h_source.html#l00132">QEQueue::ring</a>, <a class="el" href="qevent_8h_source.html#l00147">QEvent::sig</a>, and <a class="el" href="qequeue_8h_source.html#l00145">QEQueue::tail</a>.</p>

<p>Referenced by <a class="el" href="qa__defer_8c_source.html#l00045">QActive_recall()</a>.</p>

</div>
</div>
<a class="anchor" id="abec6b357b489b637afc622b6ee635921"></a><!-- doxytag: member="qequeue.h::QEQueue_init" ref="abec6b357b489b637afc622b6ee635921" args="(QEQueue *me, QEvent const *qSto[], QEQueueCtr qLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qeq__init_8c.html#abec6b357b489b637afc622b6ee635921">QEQueue_init</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_e_queue.html">QEQueue</a> *&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>qSto</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qequeue_8h.html#a3a5e050cce0e5fa8b5a87a788ef699ac">QEQueueCtr</a>&#160;</td>
          <td class="paramname"><em>qLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes the native QF event queue. </p>
<p>The parameters are as follows: <em>me</em> points to the <a class="el" href="struct_q_event.html" title="Event structure.">QEvent</a> struct to be initialized, <em>qSto</em>[] is the ring buffer storage, <em>qLen</em> is the length of the ring buffer in the units of event-pointers.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The actual capacity of the queue is qLen + 1, because of the extra location fornEvt. </dd></dl>

<p>Definition at line <a class="el" href="qeq__init_8c_source.html#l00038">38</a> of file <a class="el" href="qeq__init_8c_source.html">qeq_init.c</a>.</p>

<p>References <a class="el" href="qequeue_8h_source.html#l00137">QEQueue::end</a>, <a class="el" href="qequeue_8h_source.html#l00128">QEQueue::frontEvt</a>, <a class="el" href="qequeue_8h_source.html#l00141">QEQueue::head</a>, <a class="el" href="qequeue_8h_source.html#l00149">QEQueue::nFree</a>, <a class="el" href="qequeue_8h_source.html#l00157">QEQueue::nMin</a>, <a class="el" href="qs_8h_source.html#l00711">QS_BEGIN_</a>, <a class="el" href="qs_8h_source.html#l00645">QS_CRIT_STAT_</a>, <a class="el" href="qs_8h_source.html#l00725">QS_END_</a>, <a class="el" href="qf__pkg_8h_source.html#l00124">QS_EQC_</a>, <a class="el" href="qs___8c_source.html#l00040">QS_eqObj_</a>, <a class="el" href="qs_8h_source.html#l00777">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00074">QS_QF_EQUEUE_INIT</a>, <a class="el" href="qequeue_8h_source.html#l00132">QEQueue::ring</a>, and <a class="el" href="qequeue_8h_source.html#l00145">QEQueue::tail</a>.</p>

<p>Referenced by <a class="el" href="qk_8c_source.html#l00086">QActive_start()</a>.</p>

</div>
</div>
<a class="anchor" id="a1432f9632a6f30c434aea96cc20aa2cf"></a><!-- doxytag: member="qequeue.h::QEQueue_postFIFO" ref="a1432f9632a6f30c434aea96cc20aa2cf" args="(QEQueue *me, QEvent const *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qeq__fifo_8c.html#a1432f9632a6f30c434aea96cc20aa2cf">QEQueue_postFIFO</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_e_queue.html">QEQueue</a> *&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"raw" thread-safe QF event queue implementation for the First-In-First-Out (FIFO) event posting. You can call this function from any task context or ISR context. Please note that this function uses internally a critical section. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The function raises an assertion if the native QF queue becomes full and cannot accept the event.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qequeue_8h.html#a8ea2e15922ce2e213aa0c27e72cd730a" title="&quot;raw&quot; thread-safe QF event queue implementation for the Last-In-First-Out (LIFO) event posting...">QEQueue_postLIFO()</a>, <a class="el" href="qequeue_8h.html#ae5d5b1feb038085e2922e2f4e45b48a0" title="&quot;raw&quot; thread-safe QF event queue implementation for the event get operation.">QEQueue_get()</a> </dd></dl>

<p>Definition at line <a class="el" href="qeq__fifo_8c_source.html#l00041">41</a> of file <a class="el" href="qeq__fifo_8c_source.html">qeq_fifo.c</a>.</p>

<p>References <a class="el" href="qassert_8h_source.html#l00108">Q_ASSERT</a>, <a class="el" href="qf__pkg_8h_source.html#l00097">QF_EVT_POOL_ID_</a>, <a class="el" href="qf__pkg_8h_source.html#l00100">QF_EVT_REF_CTR_</a>, <a class="el" href="qf__pkg_8h_source.html#l00103">QF_EVT_REF_CTR_INC_</a>, <a class="el" href="qf__pkg_8h_source.html#l00109">QF_PTR_AT_</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qf__pkg_8h_source.html#l00124">QS_EQC_</a>, <a class="el" href="qs___8c_source.html#l00040">QS_eqObj_</a>, <a class="el" href="qs_8h_source.html#l00777">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00075">QS_QF_EQUEUE_POST_FIFO</a>, <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>, and <a class="el" href="qs_8h_source.html#l00753">QS_U8_</a>.</p>

<p>Referenced by <a class="el" href="qa__defer_8c_source.html#l00040">QActive_defer()</a>.</p>

</div>
</div>
<a class="anchor" id="a8ea2e15922ce2e213aa0c27e72cd730a"></a><!-- doxytag: member="qequeue.h::QEQueue_postLIFO" ref="a8ea2e15922ce2e213aa0c27e72cd730a" args="(QEQueue *me, QEvent const *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qeq__lifo_8c.html#a8ea2e15922ce2e213aa0c27e72cd730a">QEQueue_postLIFO</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_e_queue.html">QEQueue</a> *&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"raw" thread-safe QF event queue implementation for the Last-In-First-Out (LIFO) event posting. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The LIFO policy should be used only with great caution because it alters order of events in the queue. </dd>
<dd>
The function raises an assertion if the native QF queue becomes full and cannot accept the event. You can call this function from any task context or ISR context. Please note that this function uses internally a critical section.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qequeue_8h.html#a1432f9632a6f30c434aea96cc20aa2cf" title="&quot;raw&quot; thread-safe QF event queue implementation for the First-In-First-Out (FIFO) event posting...">QEQueue_postFIFO()</a>, <a class="el" href="qequeue_8h.html#ae5d5b1feb038085e2922e2f4e45b48a0" title="&quot;raw&quot; thread-safe QF event queue implementation for the event get operation.">QEQueue_get()</a> </dd></dl>

<p>Definition at line <a class="el" href="qeq__lifo_8c_source.html#l00041">41</a> of file <a class="el" href="qeq__lifo_8c_source.html">qeq_lifo.c</a>.</p>

<p>References <a class="el" href="qassert_8h_source.html#l00108">Q_ASSERT</a>, <a class="el" href="qf__pkg_8h_source.html#l00097">QF_EVT_POOL_ID_</a>, <a class="el" href="qf__pkg_8h_source.html#l00100">QF_EVT_REF_CTR_</a>, <a class="el" href="qf__pkg_8h_source.html#l00103">QF_EVT_REF_CTR_INC_</a>, <a class="el" href="qf__pkg_8h_source.html#l00109">QF_PTR_AT_</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qf__pkg_8h_source.html#l00124">QS_EQC_</a>, <a class="el" href="qs___8c_source.html#l00040">QS_eqObj_</a>, <a class="el" href="qs_8h_source.html#l00777">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00076">QS_QF_EQUEUE_POST_LIFO</a>, <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>, and <a class="el" href="qs_8h_source.html#l00753">QS_U8_</a>.</p>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 30 2012 22:21:51 for QP/C by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>

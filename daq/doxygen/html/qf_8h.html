<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>QP/C: qf.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">qf.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>QF/C platform-independent public interface.  
<a href="#details">More...</a></p>

<p><a href="qf_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_active.html">QActive</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Active Object structure.  <a href="struct_q_active.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_time_evt.html">QTimeEvt</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Time Event structure.  <a href="struct_q_time_evt.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_subscr_list.html">QSubscrList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscriber-List structure.  <a href="struct_q_subscr_list.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1272d49c23ca5852a7a8e9603ba32d31"></a><!-- doxytag: member="qf.h::QF_EVENT_SIZ_SIZE" ref="a1272d49c23ca5852a7a8e9603ba32d31" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a1272d49c23ca5852a7a8e9603ba32d31">QF_EVENT_SIZ_SIZE</a>&#160;&#160;&#160;2</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value of the macro configurable value in <a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C compiler.">qf_port.h</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2e7347d1d59f5a0410bbf92e9f141f3"></a><!-- doxytag: member="qf.h::QF_MAX_EPOOL" ref="ae2e7347d1d59f5a0410bbf92e9f141f3" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#ae2e7347d1d59f5a0410bbf92e9f141f3">QF_MAX_EPOOL</a>&#160;&#160;&#160;3</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value of the macro configurable value in <a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C compiler.">qf_port.h</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#ab7c56990d949c8708e3fe2b737f2e65c">QACTIVE_POST</a>(me_, e_, sender_)&#160;&#160;&#160;<a class="el" href="qa__fifo_8c.html#a39bfd1c186beaf9c9000f14bcc258e5b">QActive_postFIFO</a>((me_), (e_), (sender_))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the direct event posting facility <a class="el" href="qf_8h.html#a39bfd1c186beaf9c9000f14bcc258e5b" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive_postFIFO()</a>. This macro is the recommended way of posting events, because it provides the vital information for software tracing and avoids any overhead when the tracing is disabled.  <a href="#ab7c56990d949c8708e3fe2b737f2e65c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a7ddf2dd243b2bc13589a9c7d22f0e253">QActive_ctor</a>(me_, initial_)&#160;&#160;&#160;QF_ACTIVE_CTOR_(&amp;(me_)-&gt;super, (initial_))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">protected "constructor" of an active object. Performs the first step of active object initialization by assigning the initial pseudostate to the currently active state of the state machine.  <a href="#a7ddf2dd243b2bc13589a9c7d22f0e253"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80d059a0d02a2573c76f4eb5df0228ae"></a><!-- doxytag: member="qf.h::QF_TIMEEVT_CTR_SIZE" ref="a80d059a0d02a2573c76f4eb5df0228ae" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a80d059a0d02a2573c76f4eb5df0228ae">QF_TIMEEVT_CTR_SIZE</a>&#160;&#160;&#160;2</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">macro to override the default QTimeEvtCtr size. Valid values 1, 2, or 4; default 2 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a7091744cf5947a517782c530fceebc0c">QTimeEvt_postIn</a>(me_, act_, nTicks_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Arm a one-shot time event for direct event posting.  <a href="#a7091744cf5947a517782c530fceebc0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#ac551ecf84032c1c6799734671be01894">QTimeEvt_postEvery</a>(me_, act_, nTicks_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Arm a periodic time event for direct event posting.  <a href="#ac551ecf84032c1c6799734671be01894"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#afd57334f2a1664a168b0702a106e0782">QF_PUBLISH</a>(e_, sender_)&#160;&#160;&#160;<a class="el" href="qf__pspub_8c.html#a569a926df9b5180cd9e03b0c9f78adcf">QF_publish</a>((e_), (sender_))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the event publishing facility <a class="el" href="qf_8h.html#a569a926df9b5180cd9e03b0c9f78adcf" title="Publish event to the framework.">QF_publish()</a>. This macro is the recommended way of publishing events, because it provides the vital information for software tracing and avoids any overhead when the tracing is disabled.  <a href="#afd57334f2a1664a168b0702a106e0782"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a095356f76aa32cb738325abfa55e96fc">QF_TICK</a>(sender_)&#160;&#160;&#160;<a class="el" href="qf__tick_8c.html#a6eb99da137293ba6960bb2eaf9965d3e">QF_tick</a>(sender_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the system clock tick processing <a class="el" href="qf_8h.html#a6eb99da137293ba6960bb2eaf9965d3e" title="Processes all armed time events at every clock tick.">QF_tick()</a>. This macro is the recommended way of invoking clock tick processing, because it provides the vital information for software tracing and avoids any overhead when the tracing is disabled.  <a href="#a095356f76aa32cb738325abfa55e96fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3">Q_NEW</a>(evtT_, sig_)&#160;&#160;&#160;((evtT_ *)<a class="el" href="qf__new_8c.html#a2128fe3499dc6ed8100f5deed5a779a1">QF_new_</a>((QEventSize)sizeof(evtT_), (<a class="el" href="qevent_8h.html#af55248e13cdc5784f0824c7615c41b7d">QSignal</a>)(sig_)))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a dynamic event.  <a href="#abd823f3a9e8b3206a3460a108d5fa3e3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a0123f02b4c1bcf7df2cc0b11dfce8b09">QActive_start</a> (<a class="el" href="struct_q_active.html">QActive</a> *me, uint8_t prio, <a class="el" href="struct_q_event.html">QEvent</a> const *qSto[], uint32_t qLen, void *stkSto, uint32_t stkSize, <a class="el" href="struct_q_event.html">QEvent</a> const *ie)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts execution of an active object and registers the object with the framework.  <a href="#a0123f02b4c1bcf7df2cc0b11dfce8b09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a39bfd1c186beaf9c9000f14bcc258e5b">QActive_postFIFO</a> (<a class="el" href="struct_q_active.html">QActive</a> *me, <a class="el" href="struct_q_event.html">QEvent</a> const *e, void const *sender)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts an event <em>e</em> directly to the event queue of the acitve object <em>me</em> using the First-In-First-Out (FIFO) policy.  <a href="#a39bfd1c186beaf9c9000f14bcc258e5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a27984f6494cd1698adce6f8b957ad6c3">QActive_postLIFO</a> (<a class="el" href="struct_q_active.html">QActive</a> *me, <a class="el" href="struct_q_event.html">QEvent</a> const *e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts an event directly to the event queue of the active object <em>me</em> using the Last-In-First-Out (LIFO) policy.  <a href="#a27984f6494cd1698adce6f8b957ad6c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a361b6756ee8cbca0005e4c3afc4ada5b">QActive_stop</a> (<a class="el" href="struct_q_active.html">QActive</a> *me)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops execution of an active object and removes it from the framework's supervision.  <a href="#a361b6756ee8cbca0005e4c3afc4ada5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a2cb9015d643ddbf487112dfefb02eef3">QActive_subscribe</a> (<a class="el" href="struct_q_active.html">QActive</a> const *me, <a class="el" href="qevent_8h.html#af55248e13cdc5784f0824c7615c41b7d">QSignal</a> sig)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes for delivery of signal <em>sig</em> to the active object <em>me</em>.  <a href="#a2cb9015d643ddbf487112dfefb02eef3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#ab050587cf7c9786819184e423827e0ff">QActive_unsubscribe</a> (<a class="el" href="struct_q_active.html">QActive</a> const *me, <a class="el" href="qevent_8h.html#af55248e13cdc5784f0824c7615c41b7d">QSignal</a> sig)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Un-subscribes from the delivery of signal <em>sig</em> to the active object <em>me</em>.  <a href="#ab050587cf7c9786819184e423827e0ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a538f489d1d1be6f6493dbff54ff87337">QActive_unsubscribeAll</a> (<a class="el" href="struct_q_active.html">QActive</a> const *me)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Un-subscribes from the delivery of all signals to the active object <em>me</em>.  <a href="#a538f489d1d1be6f6493dbff54ff87337"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a58236a7032392f585a03122c134fec1b">QActive_defer</a> (<a class="el" href="struct_q_active.html">QActive</a> *me, <a class="el" href="struct_q_e_queue.html">QEQueue</a> *eq, <a class="el" href="struct_q_event.html">QEvent</a> const *e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defer an event to a given separate event queue.  <a href="#a58236a7032392f585a03122c134fec1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a352e707faee76e5cfd6c170a47c24fc3">QActive_recall</a> (<a class="el" href="struct_q_active.html">QActive</a> *me, <a class="el" href="struct_q_e_queue.html">QEQueue</a> *eq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall a deferred event from a given event queue.  <a href="#a352e707faee76e5cfd6c170a47c24fc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a7f7c861d8e3e884d52cfe661056e8242">QActive_get_</a> (<a class="el" href="struct_q_active.html">QActive</a> *me)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an event from the event queue of an active object.  <a href="#a7f7c861d8e3e884d52cfe661056e8242"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#aa70d5d11e10b2cbcc7d7de361ab9037d">QTimeEvt_ctor</a> (<a class="el" href="struct_q_time_evt.html">QTimeEvt</a> *me, <a class="el" href="qevent_8h.html#af55248e13cdc5784f0824c7615c41b7d">QSignal</a> sig)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The "constructor" to initialize a Time Event.  <a href="#aa70d5d11e10b2cbcc7d7de361ab9037d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a30bbb5b62b4271afc94725b651b326d6">QTimeEvt_disarm</a> (<a class="el" href="struct_q_time_evt.html">QTimeEvt</a> *me)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disarm a time event.  <a href="#a30bbb5b62b4271afc94725b651b326d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a41a513d4b6b5333b6eddad0737dd30df">QTimeEvt_rearm</a> (<a class="el" href="struct_q_time_evt.html">QTimeEvt</a> *me, QTimeEvtCtr nTicks)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearm a time event.  <a href="#a41a513d4b6b5333b6eddad0737dd30df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QTimeEvtCtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a974e633dccc976194e2df8d46e972779">QTimeEvt_ctr</a> (<a class="el" href="struct_q_time_evt.html">QTimeEvt</a> const *me)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current value of the down-counter of a time event.  <a href="#a974e633dccc976194e2df8d46e972779"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#ac5e2b55e92a199f6674b0ce0a7acf66e">QTimeEvt_arm_</a> (<a class="el" href="struct_q_time_evt.html">QTimeEvt</a> *me, <a class="el" href="struct_q_active.html">QActive</a> *act, QTimeEvtCtr nTicks)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Arm a time event (internal function to be used through macros only).  <a href="#ac5e2b55e92a199f6674b0ce0a7acf66e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#adac7eccb860d910c4e446d3143798bba">QF_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">QF initialization.  <a href="#adac7eccb860d910c4e446d3143798bba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a9f97f476eb311982be2f2e46011a04e4">QF_psInit</a> (<a class="el" href="struct_q_subscr_list.html">QSubscrList</a> *subscrSto, <a class="el" href="qevent_8h.html#af55248e13cdc5784f0824c7615c41b7d">QSignal</a> maxSignal)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish-subscribe initialization.  <a href="#a9f97f476eb311982be2f2e46011a04e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a63817909aa88407fd7d6c1ff3706a249">QF_poolInit</a> (void *poolSto, uint32_t poolSize, QEventSize evtSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Event pool initialization for dynamic allocation of events.  <a href="#a63817909aa88407fd7d6c1ff3706a249"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5">QF_run</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers control to QF to run the application.  <a href="#a7a41998117b4edb760b754f5ee3f61d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#adf9cb86740bf55c5ad55c1d44fd35921">QF_stop</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function invoked by the application layer to stop the QF application and return control to the OS/Kernel.  <a href="#adf9cb86740bf55c5ad55c1d44fd35921"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a189a6d2ece787717c81fbf51fd180732">QF_onStartup</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Startup QF callback.  <a href="#a189a6d2ece787717c81fbf51fd180732"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a5d7e181f2e679e1fa77c1e915fbee3e0">QF_onCleanup</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup QF callback.  <a href="#a5d7e181f2e679e1fa77c1e915fbee3e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#afcac91c9d71d70255fdd88db3fb16e24">QF_onIdle</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">QF idle callback (customized in BSPs for QF)  <a href="#afcac91c9d71d70255fdd88db3fb16e24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a569a926df9b5180cd9e03b0c9f78adcf">QF_publish</a> (<a class="el" href="struct_q_event.html">QEvent</a> const *e, void const *sender)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish event to the framework.  <a href="#a569a926df9b5180cd9e03b0c9f78adcf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a6eb99da137293ba6960bb2eaf9965d3e">QF_tick</a> (void const *sender)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes all armed time events at every clock tick.  <a href="#a6eb99da137293ba6960bb2eaf9965d3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#aa9425659a2eb0e6f543d2405b762dcc9">QF_add_</a> (<a class="el" href="struct_q_active.html">QActive</a> *a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an active object to be managed by the framework.  <a href="#aa9425659a2eb0e6f543d2405b762dcc9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a649efffb1de001dc75719fcf548e7045">QF_remove_</a> (<a class="el" href="struct_q_active.html">QActive</a> const *a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the active object from the framework.  <a href="#a649efffb1de001dc75719fcf548e7045"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="qevent_8h.html#a40bb5262bf908c328fbcfbe5d29d0201">char_t</a> const Q_ROM *Q_ROM_VAR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#ac590db3a7b49ddce526c527df2b7925f">QF_getVersion</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the QF version.  <a href="#ac590db3a7b49ddce526c527df2b7925f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="qevent_8h.html#a40bb5262bf908c328fbcfbe5d29d0201">char_t</a> const Q_ROM *Q_ROM_VAR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a43b0dc29cba67147b76838144a901c38">QF_getPortVersion</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the QF-port version.  <a href="#a43b0dc29cba67147b76838144a901c38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a7e3571c5cb12f59994d97d5b28560934">QF_getPoolMargin</a> (uint8_t poolId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the margin of the given event pool.  <a href="#a7e3571c5cb12f59994d97d5b28560934"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a5691094be4c3f02200e43d51535ed172">QF_getQueueMargin</a> (uint8_t prio)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the margin of the given event queue.  <a href="#a5691094be4c3f02200e43d51535ed172"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_q_event.html">QEvent</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a2128fe3499dc6ed8100f5deed5a779a1">QF_new_</a> (QEventSize evtSize, <a class="el" href="qevent_8h.html#af55248e13cdc5784f0824c7615c41b7d">QSignal</a> sig)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal QF implementation of the dynamic event allocator.  <a href="#a2128fe3499dc6ed8100f5deed5a779a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a40fe2f66781a8ac8170f0b188b879783">QF_gc</a> (<a class="el" href="struct_q_event.html">QEvent</a> const *e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recycle a dynamic event.  <a href="#a40fe2f66781a8ac8170f0b188b879783"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t const Q_ROM Q_ROM_VAR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#ab47e1f0b5f8a97bc75f7ff7d62c5e18f">QF_log2Lkup</a> [256]</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup table for (log2(n) + 1), where n is the index into the table.  <a href="#ab47e1f0b5f8a97bc75f7ff7d62c5e18f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t const Q_ROM Q_ROM_VAR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a2091dd1ed771cbef5ca70e1542829cc4">QF_pwr2Lkup</a> [65]</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup table for (1 &lt;&lt; ((n-1) % 8)), where n is the index into the table.  <a href="#a2091dd1ed771cbef5ca70e1542829cc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t const Q_ROM Q_ROM_VAR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a01186f1b8051d6e98c86f76bd9d95f32">QF_invPwr2Lkup</a> [65]</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup table for ~(1 &lt;&lt; ((n-1) % 8)), where n is the index into the table.  <a href="#a01186f1b8051d6e98c86f76bd9d95f32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t const Q_ROM Q_ROM_VAR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a765803e2ff8d3550b3334efe9c366709">QF_div8Lkup</a> [65]</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup table for (n-1)/8.  <a href="#a765803e2ff8d3550b3334efe9c366709"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_q_active.html">QActive</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qf_8h.html#a563e9f8e405ba684acba0b8f1a3ad9a6">QF_active_</a> []</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">array of registered active objects  <a href="#a563e9f8e405ba684acba0b8f1a3ad9a6"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>QF/C platform-independent public interface. </p>
<p>This header file must be included directly or indirectly in all modules (*.c files) that use QF or QK. </p>

<p>Definition in file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="abd823f3a9e8b3206a3460a108d5fa3e3"></a><!-- doxytag: member="qf.h::Q_NEW" ref="abd823f3a9e8b3206a3460a108d5fa3e3" args="(evtT_, sig_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3">Q_NEW</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">evtT_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sig_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((evtT_ *)<a class="el" href="qf__new_8c.html#a2128fe3499dc6ed8100f5deed5a779a1">QF_new_</a>((QEventSize)sizeof(evtT_), (<a class="el" href="qevent_8h.html#af55248e13cdc5784f0824c7615c41b7d">QSignal</a>)(sig_)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a dynamic event. </p>
<p>This macro returns an event pointer cast to the type <em>evtT_</em>. The event is initialized with the signal <em>sig_</em>. Internally, the macro calls the internal QF function <a class="el" href="qf_8h.html#a2128fe3499dc6ed8100f5deed5a779a1" title="Internal QF implementation of the dynamic event allocator.">QF_new_()</a>, which always returns a valid event pointer.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The internal QF function <a class="el" href="qf_8h.html#a2128fe3499dc6ed8100f5deed5a779a1" title="Internal QF implementation of the dynamic event allocator.">QF_new_()</a> raises an assertion when the allocation of the event turns out to be impossible due to event pool depletion, or incorrect (too big) size of the requested event.</dd></dl>
<p>The following example illustrates dynamic allocation of an event: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> <a class="code" href="struct_q_active.html" title="Active Object structure.">QActive</a> *AO_Table;

<a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> Philosopher_hungry(Philosopher *me, <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> <span class="keyword">const</span> *e) {
    TableEvt *pe;
    <span class="keywordflow">switch</span> (e-&gt;<a class="code" href="struct_q_event.html#af3f51670fdc402116309573cee25447d">sig</a>) {
        <span class="keywordflow">case</span> <a class="code" href="qep_8h.html#ae35e58b2153d1c63307c068315be9074ac286909dd59290d1076b51d4cfdfaefe">Q_ENTRY_SIG</a>: {
            pe = <a class="code" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW</a>(TableEvt, HUNGRY_SIG); <span class="comment">/* dynamically allocate event */</span>
            pe-&gt;philNum = me-&gt;num;
            <a class="code" href="qf_8h.html#a39bfd1c186beaf9c9000f14bcc258e5b" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive_postFIFO</a>(AO_Table, (<a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> *)pe);     <span class="comment">/* direct posting */</span>
            <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED</a>();
        }
        . . .
    }
    <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#ad8abd2f7098c41ec464343d9d8f1eadc" title="Designates the superstate of a given state in an HSM.">Q_SUPER</a>(&amp;<a class="code" href="qep_8h.html#a44cb0854e4c7c43ac06b20c1e11d4a93" title="the top-state.">QHsm_top</a>);
}
</pre></div> 
<p>Definition at line <a class="el" href="qf_8h_source.html#l01024">1024</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7ddf2dd243b2bc13589a9c7d22f0e253"></a><!-- doxytag: member="qf.h::QActive_ctor" ref="a7ddf2dd243b2bc13589a9c7d22f0e253" args="(me_, initial_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="qf_8h.html#a7ddf2dd243b2bc13589a9c7d22f0e253">QActive_ctor</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">me_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">initial_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;QF_ACTIVE_CTOR_(&amp;(me_)-&gt;super, (initial_))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>protected "constructor" of an active object. Performs the first step of active object initialization by assigning the initial pseudostate to the currently active state of the state machine. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Must be called only by the "constructors" of the derived active objects, as shown in the following example: <div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> Philosopher_ctor(Philosopher *me) {
    <a class="code" href="qf_8h.html#a7ddf2dd243b2bc13589a9c7d22f0e253" title="protected &quot;constructor&quot; of an active object. Performs the first step of active object initialization ...">QActive_ctor</a>(&amp;me-&gt;super, (<a class="code" href="qep_8h.html#ac2c368a1ec5e2037c5f4d54f24b3da95" title="pointer to state-handler function">QStateHandler</a>)&amp;Philosopher_initial);
    <a class="code" href="qf_8h.html#aa70d5d11e10b2cbcc7d7de361ab9037d" title="The &quot;constructor&quot; to initialize a Time Event.">QTimeEvt_ctor</a>(&amp;me-&gt;timeEvt, TIMEOUT_SIG);
}
</pre></div></dd>
<dd>
Must be called before <a class="el" href="qf_8h.html#a0123f02b4c1bcf7df2cc0b11dfce8b09" title="Starts execution of an active object and registers the object with the framework.">QActive_start()</a>.</dd></dl>
<p>The following example illustrates how to invoke <a class="el" href="qep_8h.html#ad66297c5cd81f3cadc5b4dafc8f11f8c" title="Protected &quot;constructor&quot; of a FSM.">QFsm_ctor()</a> in the "constructor" of a derived state machine: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> QCalc_ctor(QCalc *me) {
    <a class="code" href="qep_8h.html#a8b773acc2e243ce416869ab83ee5679c" title="protected &quot;constructor&quot; of a HSM. Performs the first step of HSM initialization by assigning the init...">QHsm_ctor</a>(&amp;me-&gt;super, (<a class="code" href="qep_8h.html#ac2c368a1ec5e2037c5f4d54f24b3da95" title="pointer to state-handler function">QStateHandler</a>)&amp;QCalc_initial);
}
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qep_8h.html#a8b773acc2e243ce416869ab83ee5679c" title="protected &quot;constructor&quot; of a HSM. Performs the first step of HSM initialization by assigning the init...">QHsm_ctor</a> and <a class="el" href="qep_8h.html#ad66297c5cd81f3cadc5b4dafc8f11f8c" title="Protected &quot;constructor&quot; of a FSM.">QFsm_ctor</a> </dd></dl>

<p>Definition at line <a class="el" href="qf_8h_source.html#l00313">313</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab7c56990d949c8708e3fe2b737f2e65c"></a><!-- doxytag: member="qf.h::QACTIVE_POST" ref="ab7c56990d949c8708e3fe2b737f2e65c" args="(me_, e_, sender_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="qf_8h.html#ab7c56990d949c8708e3fe2b737f2e65c">QACTIVE_POST</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">me_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sender_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="qa__fifo_8c.html#a39bfd1c186beaf9c9000f14bcc258e5b">QActive_postFIFO</a>((me_), (e_), (sender_))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Invoke the direct event posting facility <a class="el" href="qf_8h.html#a39bfd1c186beaf9c9000f14bcc258e5b" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive_postFIFO()</a>. This macro is the recommended way of posting events, because it provides the vital information for software tracing and avoids any overhead when the tracing is disabled. </p>
<p>This macro takes the last argument <em>sender_</em>, which is a pointer to the sender object. This argument is actually only used when QS software tracing is disabled (macro #Q_SPY is defined). When QS software tracing is not enabled, the macro calls <a class="el" href="qf_8h.html#a569a926df9b5180cd9e03b0c9f78adcf" title="Publish event to the framework.">QF_publish()</a> without the <em>sender_</em> argument, so the overhead of passing this extra argument is entirely avoided.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>the pointer to the sender object is not necessarily a poiner to an active object. In fact, if <a class="el" href="qf_8h.html#ab7c56990d949c8708e3fe2b737f2e65c" title="Invoke the direct event posting facility QActive_postFIFO(). This macro is the recommended way of pos...">QACTIVE_POST()</a> is called from an interrupt or other context, you can create a unique object just to unambiguously identify the publisher of the event.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#a39bfd1c186beaf9c9000f14bcc258e5b" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive_postFIFO()</a>. </dd></dl>

<p>Definition at line <a class="el" href="qf_8h_source.html#l00275">275</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

<p>Referenced by <a class="el" href="qf__pspub_8c_source.html#l00043">QF_publish()</a>, and <a class="el" href="qf__tick_8c_source.html#l00043">QF_tick()</a>.</p>

</div>
</div>
<a class="anchor" id="afd57334f2a1664a168b0702a106e0782"></a><!-- doxytag: member="qf.h::QF_PUBLISH" ref="afd57334f2a1664a168b0702a106e0782" args="(e_, sender_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="qf_8h.html#afd57334f2a1664a168b0702a106e0782">QF_PUBLISH</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sender_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="qf__pspub_8c.html#a569a926df9b5180cd9e03b0c9f78adcf">QF_publish</a>((e_), (sender_))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Invoke the event publishing facility <a class="el" href="qf_8h.html#a569a926df9b5180cd9e03b0c9f78adcf" title="Publish event to the framework.">QF_publish()</a>. This macro is the recommended way of publishing events, because it provides the vital information for software tracing and avoids any overhead when the tracing is disabled. </p>
<p>This macro takes the last argument <em>sender_</em>, which is a pointer to the sender object. This argument is actually only used when QS software tracing is enabled (macro #Q_SPY is defined). When QS software tracing is disabled, the macro calls <a class="el" href="qf_8h.html#a569a926df9b5180cd9e03b0c9f78adcf" title="Publish event to the framework.">QF_publish()</a> without the <em>sender_</em> argument, so the overhead of passing this extra argument is entirely avoided.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>the pointer to the sender object is not necessarily a poiner to an active object. In fact, if <a class="el" href="qf_8h.html#afd57334f2a1664a168b0702a106e0782" title="Invoke the event publishing facility QF_publish(). This macro is the recommended way of publishing ev...">QF_PUBLISH()</a> is called from an interrupt or other context, you can create a unique object just to unambiguously identify the publisher of the event.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#a569a926df9b5180cd9e03b0c9f78adcf" title="Publish event to the framework.">QF_publish()</a>. </dd></dl>

<p>Definition at line <a class="el" href="qf_8h_source.html#l00869">869</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a class="anchor" id="a095356f76aa32cb738325abfa55e96fc"></a><!-- doxytag: member="qf.h::QF_TICK" ref="a095356f76aa32cb738325abfa55e96fc" args="(sender_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="qf_8h.html#a095356f76aa32cb738325abfa55e96fc">QF_TICK</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sender_</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="qf__tick_8c.html#a6eb99da137293ba6960bb2eaf9965d3e">QF_tick</a>(sender_)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Invoke the system clock tick processing <a class="el" href="qf_8h.html#a6eb99da137293ba6960bb2eaf9965d3e" title="Processes all armed time events at every clock tick.">QF_tick()</a>. This macro is the recommended way of invoking clock tick processing, because it provides the vital information for software tracing and avoids any overhead when the tracing is disabled. </p>
<p>This macro takes the argument <em>sender_</em>, which is a pointer to the sender object. This argument is actually only used when QS software tracing is enabled (macro #Q_SPY is defined). When QS software tracing is disabled, the macro calls <a class="el" href="qf_8h.html#a6eb99da137293ba6960bb2eaf9965d3e" title="Processes all armed time events at every clock tick.">QF_tick()</a> without any arguments, so the overhead of passing this extra argument is entirely avoided.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>the pointer to the sender object is not necessarily a poiner to an active object. In fact, typically <a class="el" href="qf_8h.html#a095356f76aa32cb738325abfa55e96fc" title="Invoke the system clock tick processing QF_tick(). This macro is the recommended way of invoking cloc...">QF_TICK()</a> will be called from an interrupt, in which case you would create a unique object just to unambiguously identify the ISR as the sender of the time events.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#a6eb99da137293ba6960bb2eaf9965d3e" title="Processes all armed time events at every clock tick.">QF_tick()</a>. </dd></dl>

<p>Definition at line <a class="el" href="qf_8h_source.html#l00915">915</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac551ecf84032c1c6799734671be01894"></a><!-- doxytag: member="qf.h::QTimeEvt_postEvery" ref="ac551ecf84032c1c6799734671be01894" args="(me_, act_, nTicks_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="qf_8h.html#ac551ecf84032c1c6799734671be01894">QTimeEvt_postEvery</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">me_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">act_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nTicks_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> { \
    (me_)-&gt;interval = (nTicks_); \
    QTimeEvt_arm_((me_), (act_), (nTicks_)); \
} <span class="keywordflow">while</span> (0)
</pre></div>
<p>Arm a periodic time event for direct event posting. </p>
<p>Arms a time event <em>me_</em> to fire every <em>nTicks_</em> clock ticks (periodic time event). The time event gets directly posted (using the FIFO policy) into the event queue of the active object <em>act_</em>.</p>
<p>After posting, the time event gets automatically re-armed to fire again in the specified <em>nTicks_</em> clock ticks.</p>
<p>A periodic time event can be disarmed only by calling the <a class="el" href="qf_8h.html#a30bbb5b62b4271afc94725b651b326d6" title="Disarm a time event.">QTimeEvt_disarm()</a> function. After disarming, the time event can be reused for a one-shot or periodic timeout requests.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>An attempt to reuse (arm again) a running periodic time event raises an assertion.</dd></dl>
<p>Also, a periodic time event can be re-armed to shorten or extend the current period by calling the <a class="el" href="qf_8h.html#a41a513d4b6b5333b6eddad0737dd30df" title="Rearm a time event.">QTimeEvt_rearm()</a> function. After adjusting the current period, the periodic time event goes back timing out at the original rate. </p>

<p>Definition at line <a class="el" href="qf_8h_source.html#l00590">590</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7091744cf5947a517782c530fceebc0c"></a><!-- doxytag: member="qf.h::QTimeEvt_postIn" ref="a7091744cf5947a517782c530fceebc0c" args="(me_, act_, nTicks_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="qf_8h.html#a7091744cf5947a517782c530fceebc0c">QTimeEvt_postIn</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">me_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">act_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nTicks_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> { \
    (me_)-&gt;interval = (QTimeEvtCtr)0; \
    QTimeEvt_arm_((me_), (act_), (nTicks_)); \
} <span class="keywordflow">while</span> (0)
</pre></div>
<p>Arm a one-shot time event for direct event posting. </p>
<p>Arms a time event <em>me_</em> to fire in <em>nTicks_</em> clock ticks (one-shot time event). The time event gets directly posted (using the FIFO policy) into the event queue of the active object <em>act_</em>.</p>
<p>After posting, the time event gets automatically disarmed and can be reused for a one-shot or periodic timeout requests.</p>
<p>A one-shot time event can be disarmed at any time by calling the <a class="el" href="qf_8h.html#a30bbb5b62b4271afc94725b651b326d6" title="Disarm a time event.">QTimeEvt_disarm()</a> function. Also, a one-shot time event can be re-armed to fire in a different number of clock ticks by calling the <a class="el" href="qf_8h.html#a41a513d4b6b5333b6eddad0737dd30df" title="Rearm a time event.">QTimeEvt_rearm()</a> function.</p>
<p>The following example shows how to arm a one-shot time event from a state machine of an active object: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> Philosopher_eating(Philosopher *me, <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> <span class="keyword">const</span> *e) {
    TableEvt *pe;
    <span class="keywordflow">switch</span> (e-&gt;<a class="code" href="struct_q_event.html#af3f51670fdc402116309573cee25447d">sig</a>) {
        <span class="keywordflow">case</span> <a class="code" href="qep_8h.html#ae35e58b2153d1c63307c068315be9074ac286909dd59290d1076b51d4cfdfaefe">Q_ENTRY_SIG</a>: {
            <a class="code" href="qf_8h.html#a7091744cf5947a517782c530fceebc0c" title="Arm a one-shot time event for direct event posting.">QTimeEvt_postIn</a>(&amp;me-&gt;timeEvt, (<a class="code" href="struct_q_active.html" title="Active Object structure.">QActive</a> *)me, EAT_TIME);
            <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED</a>();
        }
        <span class="keywordflow">case</span> TIMEOUT_SIG: {
            <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both in the FSMs and H...">Q_TRAN</a>(&amp;Philosopher_thinking);
        }
        <span class="keywordflow">case</span> <a class="code" href="qep_8h.html#ae35e58b2153d1c63307c068315be9074ab54538c21a62926a2f1d63d8fd45bf5c">Q_EXIT_SIG</a>: {
            pe = <a class="code" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW</a>(TableEvt, DONE_SIG);
            pe-&gt;philNum = me-&gt;num;
            <a class="code" href="qf_8h.html#a569a926df9b5180cd9e03b0c9f78adcf" title="Publish event to the framework.">QF_publish</a>((<a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> *)pe);
            <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED</a>();
        }
    }
    <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#ad8abd2f7098c41ec464343d9d8f1eadc" title="Designates the superstate of a given state in an HSM.">Q_SUPER</a>(&amp;<a class="code" href="qep_8h.html#a44cb0854e4c7c43ac06b20c1e11d4a93" title="the top-state.">QHsm_top</a>);
}
</pre></div> 
<p>Definition at line <a class="el" href="qf_8h_source.html#l00564">564</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a58236a7032392f585a03122c134fec1b"></a><!-- doxytag: member="qf.h::QActive_defer" ref="a58236a7032392f585a03122c134fec1b" args="(QActive *me, QEQueue *eq, QEvent const *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qa__defer_8c.html#a58236a7032392f585a03122c134fec1b">QActive_defer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_q_e_queue.html">QEQueue</a> *&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defer an event to a given separate event queue. </p>
<p>This function is part of the event deferral support. An active object uses this function to defer an event <em>e</em> to the QF-supported native event queue <em>eq</em>. QF correctly accounts for another outstanding reference to the event and will not recycle the event at the end of the RTC step. Later, the active object might recall one event at a time from the event queue.</p>
<p>An active object can use multiple event queues to defer events of different kinds.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#a352e707faee76e5cfd6c170a47c24fc3" title="Recall a deferred event from a given event queue.">QActive_recall()</a>, <a class="el" href="struct_q_e_queue.html" title="Native QF Event Queue.">QEQueue</a> </dd></dl>

<p>Definition at line <a class="el" href="qa__defer_8c_source.html#l00040">40</a> of file <a class="el" href="qa__defer_8c_source.html">qa_defer.c</a>.</p>

<p>References <a class="el" href="qeq__fifo_8c_source.html#l00041">QEQueue_postFIFO()</a>.</p>

</div>
</div>
<a class="anchor" id="a7f7c861d8e3e884d52cfe661056e8242"></a><!-- doxytag: member="qf.h::QActive_get_" ref="a7f7c861d8e3e884d52cfe661056e8242" args="(QActive *me)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_event.html">QEvent</a> const* <a class="el" href="qa__get___8c.html#a7f7c861d8e3e884d52cfe661056e8242">QActive_get_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *&#160;</td>
          <td class="paramname"><em>me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an event from the event queue of an active object. </p>
<p>This function is used internally by a QF port to extract events from the event queue of an active object. This function depends on the event queue implementation and is sometimes implemented in the QF port (qf_port.c file). Depending on the underlying OS or kernel, the function might block the calling thread when no events are available.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#a39bfd1c186beaf9c9000f14bcc258e5b" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive_postFIFO()</a>, <a class="el" href="qf_8h.html#a27984f6494cd1698adce6f8b957ad6c3" title="Posts an event directly to the event queue of the active object me using the Last-In-First-Out (LIFO)...">QActive_postLIFO()</a> </dd></dl>

<p>Definition at line <a class="el" href="qa__get___8c_source.html#l00043">43</a> of file <a class="el" href="qa__get___8c_source.html">qa_get_.c</a>.</p>

<p>References <a class="el" href="qk_8h_source.html#l00154">QACTIVE_EQUEUE_ONEMPTY_</a>, <a class="el" href="qk_8h_source.html#l00100">QACTIVE_EQUEUE_WAIT_</a>, <a class="el" href="qf__pkg_8h_source.html#l00097">QF_EVT_POOL_ID_</a>, <a class="el" href="qf__pkg_8h_source.html#l00100">QF_EVT_REF_CTR_</a>, <a class="el" href="qf__pkg_8h_source.html#l00109">QF_PTR_AT_</a>, <a class="el" href="qs___8c_source.html#l00038">QS_aoObj_</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qf__pkg_8h_source.html#l00124">QS_EQC_</a>, <a class="el" href="qs_8h_source.html#l00777">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00072">QS_QF_ACTIVE_GET</a>, <a class="el" href="qs_8h_source.html#l00073">QS_QF_ACTIVE_GET_LAST</a>, <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>, <a class="el" href="qs_8h_source.html#l00753">QS_U8_</a>, and <a class="el" href="qevent_8h_source.html#l00147">QEvent::sig</a>.</p>

<p>Referenced by <a class="el" href="qvanilla_8c_source.html#l00057">QF_run()</a>, <a class="el" href="qk__sched_8c_source.html#l00041">QK_sched_()</a>, and <a class="el" href="qk__ext_8c_source.html#l00041">QK_schedExt_()</a>.</p>

</div>
</div>
<a class="anchor" id="a39bfd1c186beaf9c9000f14bcc258e5b"></a><!-- doxytag: member="qf.h::QActive_postFIFO" ref="a39bfd1c186beaf9c9000f14bcc258e5b" args="(QActive *me, QEvent const *e, void const *sender)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qa__fifo_8c.html#a39bfd1c186beaf9c9000f14bcc258e5b">QActive_postFIFO</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>sender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Posts an event <em>e</em> directly to the event queue of the acitve object <em>me</em> using the First-In-First-Out (FIFO) policy. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>this function should be called only via the macro <a class="el" href="qf_8h.html#ab7c56990d949c8708e3fe2b737f2e65c" title="Invoke the direct event posting facility QActive_postFIFO(). This macro is the recommended way of pos...">QACTIVE_POST</a></dd></dl>
<p>Direct event posting is the simplest asynchronous communication method available in QF. The following example illustrates how the Philo active object posts directly the HUNGRY event to the Table active object. </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> <a class="code" href="struct_q_active.html" title="Active Object structure.">QActive</a> *AO_Table;

<a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> Philosopher_hungry(Philosopher *me, <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> <span class="keyword">const</span> *e) {
    TableEvt *pe;
    <span class="keywordflow">switch</span> (e-&gt;<a class="code" href="struct_q_event.html#af3f51670fdc402116309573cee25447d">sig</a>) {
        <span class="keywordflow">case</span> <a class="code" href="qep_8h.html#ae35e58b2153d1c63307c068315be9074ac286909dd59290d1076b51d4cfdfaefe">Q_ENTRY_SIG</a>: {
            pe = <a class="code" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW</a>(TableEvt, HUNGRY_SIG); <span class="comment">/* dynamically allocate event */</span>
            pe-&gt;philNum = me-&gt;num;
            <a class="code" href="qf_8h.html#a39bfd1c186beaf9c9000f14bcc258e5b" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive_postFIFO</a>(AO_Table, (<a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> *)pe);     <span class="comment">/* direct posting */</span>
            <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED</a>();
        }
        . . .
    }
    <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#ad8abd2f7098c41ec464343d9d8f1eadc" title="Designates the superstate of a given state in an HSM.">Q_SUPER</a>(&amp;<a class="code" href="qep_8h.html#a44cb0854e4c7c43ac06b20c1e11d4a93" title="the top-state.">QHsm_top</a>);
}
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>The producer of the event (Philo in this case) must only "know" the recipient (Table) by a generic (<a class="el" href="struct_q_active.html" title="Active Object structure.">QActive</a> *AO_Table) pointer, but the specific definition of the Table structure is not required.</dd>
<dd>
Direct event posting should not be confused with direct event dispatching. In contrast to asynchronous event posting through event queues, direct event dispatching is synchronous. Direct event dispatching occurs when you call <a class="el" href="qep_8h.html#aa3aae49d6ee450d49a876b203db19105" title="Dispatches an event to a HSM.">QHsm_dispatch()</a>, or <a class="el" href="qep_8h.html#a514cbffa08717fdc247fc36df3f300ef" title="Dispatches an event to a FSM.">QFsm_dispatch()</a> function. </dd></dl>

<p>Definition at line <a class="el" href="qa__fifo_8c_source.html#l00046">46</a> of file <a class="el" href="qa__fifo_8c_source.html">qa_fifo.c</a>.</p>

<p>References <a class="el" href="qf_8h_source.html#l00156">QActive::eQueue</a>, <a class="el" href="qassert_8h_source.html#l00108">Q_ASSERT</a>, <a class="el" href="qk_8h_source.html#l00131">QACTIVE_EQUEUE_SIGNAL_</a>, <a class="el" href="qf__pkg_8h_source.html#l00097">QF_EVT_POOL_ID_</a>, <a class="el" href="qf__pkg_8h_source.html#l00100">QF_EVT_REF_CTR_</a>, <a class="el" href="qf__pkg_8h_source.html#l00103">QF_EVT_REF_CTR_INC_</a>, <a class="el" href="qf__pkg_8h_source.html#l00109">QF_PTR_AT_</a>, <a class="el" href="qs___8c_source.html#l00038">QS_aoObj_</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qf__pkg_8h_source.html#l00124">QS_EQC_</a>, <a class="el" href="qs_8h_source.html#l00777">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00070">QS_QF_ACTIVE_POST_FIFO</a>, <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>, <a class="el" href="qs_8h_source.html#l00753">QS_U8_</a>, and <a class="el" href="qevent_8h_source.html#l00147">QEvent::sig</a>.</p>

</div>
</div>
<a class="anchor" id="a27984f6494cd1698adce6f8b957ad6c3"></a><!-- doxytag: member="qf.h::QActive_postLIFO" ref="a27984f6494cd1698adce6f8b957ad6c3" args="(QActive *me, QEvent const *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qa__lifo_8c.html#a27984f6494cd1698adce6f8b957ad6c3">QActive_postLIFO</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Posts an event directly to the event queue of the active object <em>me</em> using the Last-In-First-Out (LIFO) policy. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The LIFO policy should be used only for self-posting and with caution because it alters order of events in the queue.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#a39bfd1c186beaf9c9000f14bcc258e5b" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive_postFIFO()</a> </dd></dl>

<p>Definition at line <a class="el" href="qa__lifo_8c_source.html#l00043">43</a> of file <a class="el" href="qa__lifo_8c_source.html">qa_lifo.c</a>.</p>

<p>References <a class="el" href="qassert_8h_source.html#l00108">Q_ASSERT</a>, <a class="el" href="qk_8h_source.html#l00131">QACTIVE_EQUEUE_SIGNAL_</a>, <a class="el" href="qf__pkg_8h_source.html#l00097">QF_EVT_POOL_ID_</a>, <a class="el" href="qf__pkg_8h_source.html#l00100">QF_EVT_REF_CTR_</a>, <a class="el" href="qf__pkg_8h_source.html#l00103">QF_EVT_REF_CTR_INC_</a>, <a class="el" href="qf__pkg_8h_source.html#l00109">QF_PTR_AT_</a>, <a class="el" href="qs___8c_source.html#l00038">QS_aoObj_</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qf__pkg_8h_source.html#l00124">QS_EQC_</a>, <a class="el" href="qs_8h_source.html#l00777">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00071">QS_QF_ACTIVE_POST_LIFO</a>, <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>, and <a class="el" href="qs_8h_source.html#l00753">QS_U8_</a>.</p>

<p>Referenced by <a class="el" href="qa__defer_8c_source.html#l00045">QActive_recall()</a>.</p>

</div>
</div>
<a class="anchor" id="a352e707faee76e5cfd6c170a47c24fc3"></a><!-- doxytag: member="qf.h::QActive_recall" ref="a352e707faee76e5cfd6c170a47c24fc3" args="(QActive *me, QEQueue *eq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="qa__defer_8c.html#a352e707faee76e5cfd6c170a47c24fc3">QActive_recall</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_q_e_queue.html">QEQueue</a> *&#160;</td>
          <td class="paramname"><em>eq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recall a deferred event from a given event queue. </p>
<p>This function is part of the event deferral support. An active object uses this function to recall a deferred event from a given QF event queue. Recalling an event means that it is removed from the deferred event queue <em>eq</em> and posted (LIFO) to the event queue of the active object.</p>
<p><a class="el" href="qf_8h.html#a352e707faee76e5cfd6c170a47c24fc3" title="Recall a deferred event from a given event queue.">QActive_recall()</a> returns 1 (TRUE) if an event has been recalled. Otherwise the function returns 0.</p>
<p>An active object can use multiple event queues to defer events of different kinds.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#a352e707faee76e5cfd6c170a47c24fc3" title="Recall a deferred event from a given event queue.">QActive_recall()</a>, <a class="el" href="struct_q_e_queue.html" title="Native QF Event Queue.">QEQueue</a>, <a class="el" href="qf_8h.html#a27984f6494cd1698adce6f8b957ad6c3" title="Posts an event directly to the event queue of the active object me using the Last-In-First-Out (LIFO)...">QActive_postLIFO()</a> </dd></dl>

<p>Definition at line <a class="el" href="qa__defer_8c_source.html#l00045">45</a> of file <a class="el" href="qa__defer_8c_source.html">qa_defer.c</a>.</p>

<p>References <a class="el" href="qassert_8h_source.html#l00108">Q_ASSERT</a>, <a class="el" href="qa__lifo_8c_source.html#l00043">QActive_postLIFO()</a>, <a class="el" href="qeq__get_8c_source.html#l00041">QEQueue_get()</a>, <a class="el" href="qf__pkg_8h_source.html#l00097">QF_EVT_POOL_ID_</a>, <a class="el" href="qf__pkg_8h_source.html#l00100">QF_EVT_REF_CTR_</a>, and <a class="el" href="qf__pkg_8h_source.html#l00106">QF_EVT_REF_CTR_DEC_</a>.</p>

</div>
</div>
<a class="anchor" id="a0123f02b4c1bcf7df2cc0b11dfce8b09"></a><!-- doxytag: member="qf.h::QActive_start" ref="a0123f02b4c1bcf7df2cc0b11dfce8b09" args="(QActive *me, uint8_t prio, QEvent const *qSto[], uint32_t qLen, void *stkSto, uint32_t stkSize, QEvent const *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qk_8c.html#a0123f02b4c1bcf7df2cc0b11dfce8b09">QActive_start</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>qSto</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>qLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stkSto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stkSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>ie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts execution of an active object and registers the object with the framework. </p>
<p>The function takes seven arguments. <em>me</em> is a pointer to the active object structure. <em>prio</em> is the priority of the active object. QF allows you to start up to 63 active objects, each one having a unique priority number between 1 and 63 inclusive, where higher numerical values correspond to higher priority (urgency) of the active object relative to the others. <em>qSto</em>[] and <em>qLen</em> arguments are the storage and size of the event queue used by this active object. <em>stkSto</em> and <em>stkSize</em> are the stack storage and size in bytes. Please note that a per-active object stack is used only when the underlying OS requies it. If the stack is not required, or the underlying OS allocates the stack internally, the <em>stkSto</em> should be NULL and/or <em>stkSize</em> should be 0. <em>ie</em> is an optional initialization event that can be used to pass additional startup data to the active object. (Pass NULL if your active object does not expect the initialization event).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is strongly OS-dependent and must be defined in the QF port to a particular platform.</dd></dl>
<p>The following example shows starting of the Philosopher object when a per-task stack is required: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> Philosopher l_philo[N];              <span class="comment">/* N Philosopher active objects */</span>
<span class="keyword">static</span> <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> <span class="keyword">const</span> *l_philQueueSto[N][N];<span class="comment">/* storage for Philo event queues */</span>
<span class="keyword">static</span> <span class="keywordtype">int</span> l_philoStk[N][256]; <span class="comment">/* stacks for the Philosopher active objects */</span>

main() {
    . . .
    <span class="keywordflow">for</span> (n = 0; n &lt; N; ++n) {
        TableEvt ie;        <span class="comment">/* initialization event for the Philosopher HSM */</span>
        ie.philNum = n;
        Philosopher_ctor(&amp;l_philo[n]);
        <a class="code" href="qf_8h.html#a0123f02b4c1bcf7df2cc0b11dfce8b09" title="Starts execution of an active object and registers the object with the framework.">QActive_start</a>((<a class="code" href="struct_q_active.html" title="Active Object structure.">QActive</a> *)&amp;l_philo[n],       <span class="comment">/* Philosopher number n */</span>
                      (uint8_t)(n*10 + 1),                      <span class="comment">/* priority */</span>
                      l_philoQueueSto[n], <a class="code" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_philoQueueSto[n]),<span class="comment">/*queue */</span>
                      l_philoStk[n], <span class="keyword">sizeof</span>(l_philoStk[n]),<span class="comment">/*uC/OS-II stack */</span>
                      (<a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> <span class="keyword">const</span> *)&amp;ie);         <span class="comment">/* initialization event */</span>
    }
    . . .
} 
</pre></div> 
<p>Definition at line <a class="el" href="qvanilla_8c_source.html#l00088">88</a> of file <a class="el" href="qvanilla_8c_source.html">qvanilla.c</a>.</p>

<p>References <a class="el" href="qf_8h_source.html#l00156">QActive::eQueue</a>, <a class="el" href="qf_8h_source.html#l00182">QActive::prio</a>, <a class="el" href="qassert_8h_source.html#l00108">Q_ASSERT</a>, <a class="el" href="qassert_8h_source.html#l00173">Q_REQUIRE</a>, <a class="el" href="qeq__init_8c_source.html#l00038">QEQueue_init()</a>, <a class="el" href="qf__act_8c_source.html#l00058">QF_add_()</a>, <a class="el" href="qf__port_8h_source.html#l00053">QF_MAX_ACTIVE</a>, <a class="el" href="qs_8h_source.html#l01064">QS_FLUSH</a>, and <a class="el" href="qf_8h_source.html#l00144">QActive::super</a>.</p>

</div>
</div>
<a class="anchor" id="a361b6756ee8cbca0005e4c3afc4ada5b"></a><!-- doxytag: member="qf.h::QActive_stop" ref="a361b6756ee8cbca0005e4c3afc4ada5b" args="(QActive *me)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qk_8c.html#a361b6756ee8cbca0005e4c3afc4ada5b">QActive_stop</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *&#160;</td>
          <td class="paramname"><em>me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stops execution of an active object and removes it from the framework's supervision. </p>
<p>The preferred way of calling this function is from within the active object that needs to stop. In other words, an active object should stop itself rather than being stopped by some other entity. This policy works best, because only the active object itself "knows" when it has reached the appropriate state for the shutdown.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is strongly OS-dependent and should be defined in the QF port to a particular platform. This function is optional in embedded systems where active objects never need to be stopped. </dd></dl>

<p>Definition at line <a class="el" href="qvanilla_8c_source.html#l00105">105</a> of file <a class="el" href="qvanilla_8c_source.html">qvanilla.c</a>.</p>

<p>References <a class="el" href="qf__act_8c_source.html#l00078">QF_remove_()</a>.</p>

</div>
</div>
<a class="anchor" id="a2cb9015d643ddbf487112dfefb02eef3"></a><!-- doxytag: member="qf.h::QActive_subscribe" ref="a2cb9015d643ddbf487112dfefb02eef3" args="(QActive const *me, QSignal sig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qa__sub_8c.html#a2cb9015d643ddbf487112dfefb02eef3">QActive_subscribe</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> const *&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qevent_8h.html#af55248e13cdc5784f0824c7615c41b7d">QSignal</a>&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subscribes for delivery of signal <em>sig</em> to the active object <em>me</em>. </p>
<p>This function is part of the Publish-Subscribe event delivery mechanism available in QF. Subscribing to an event means that the framework will start posting all published events with a given signal <em>sig</em> to the event queue of the active object <em>me</em>.</p>
<p>The following example shows how the Table active object subscribes to three signals in the initial transition: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> Table_initial(Table *me, <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> <span class="keyword">const</span> *e) {
    uint8_t n;
    (void)e;                               <span class="comment">/* suppress the compiler warning */</span>

    <a class="code" href="qf_8h.html#a2cb9015d643ddbf487112dfefb02eef3" title="Subscribes for delivery of signal sig to the active object me.">QActive_subscribe</a>((<a class="code" href="struct_q_active.html" title="Active Object structure.">QActive</a> *)me, HUNGRY_SIG);   <span class="comment">/* subscribe to HUNGRY */</span>
    <a class="code" href="qf_8h.html#a2cb9015d643ddbf487112dfefb02eef3" title="Subscribes for delivery of signal sig to the active object me.">QActive_subscribe</a>((<a class="code" href="struct_q_active.html" title="Active Object structure.">QActive</a> *)me, DONE_SIG);              <span class="comment">/*... to DONE */</span>
    <a class="code" href="qf_8h.html#a2cb9015d643ddbf487112dfefb02eef3" title="Subscribes for delivery of signal sig to the active object me.">QActive_subscribe</a>((<a class="code" href="struct_q_active.html" title="Active Object structure.">QActive</a> *)me, TERMINATE_SIG); <span class="comment">/*...and to TERMINATE */</span>
    <span class="keywordflow">for</span> (n = 0; n &lt; N; ++n) {
        me-&gt;fork[n] = FREE;
        me-&gt;isHungry[n] = 0;
    }
    <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both in the FSMs and H...">Q_TRAN</a>(&amp;Table_serving);
}
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#a569a926df9b5180cd9e03b0c9f78adcf" title="Publish event to the framework.">QF_publish()</a>, <a class="el" href="qf_8h.html#ab050587cf7c9786819184e423827e0ff" title="Un-subscribes from the delivery of signal sig to the active object me.">QActive_unsubscribe()</a>, and <a class="el" href="qf_8h.html#a538f489d1d1be6f6493dbff54ff87337" title="Un-subscribes from the delivery of all signals to the active object me.">QActive_unsubscribeAll()</a> </dd></dl>

<p>Definition at line <a class="el" href="qa__sub_8c_source.html#l00040">40</a> of file <a class="el" href="qa__sub_8c_source.html">qa_sub.c</a>.</p>

<p>References <a class="el" href="qassert_8h_source.html#l00173">Q_REQUIRE</a>, <a class="el" href="qep_8h_source.html#l00283">Q_USER_SIG</a>, <a class="el" href="qf__act_8c_source.html#l00041">QF_active_</a>, <a class="el" href="qf__pwr2_8c_source.html#l00077">QF_div8Lkup</a>, <a class="el" href="qf__port_8h_source.html#l00053">QF_MAX_ACTIVE</a>, <a class="el" href="qf__psini_8c_source.html#l00039">QF_maxSignal_</a>, <a class="el" href="qf__pkg_8h_source.html#l00109">QF_PTR_AT_</a>, <a class="el" href="qf__pwr2_8c_source.html#l00037">QF_pwr2Lkup</a>, <a class="el" href="qf__psini_8c_source.html#l00038">QF_subscrList_</a>, <a class="el" href="qs___8c_source.html#l00038">QS_aoObj_</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00777">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00068">QS_QF_ACTIVE_SUBSCRIBE</a>, and <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>.</p>

</div>
</div>
<a class="anchor" id="ab050587cf7c9786819184e423827e0ff"></a><!-- doxytag: member="qf.h::QActive_unsubscribe" ref="ab050587cf7c9786819184e423827e0ff" args="(QActive const *me, QSignal sig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qa__usub_8c.html#ab050587cf7c9786819184e423827e0ff">QActive_unsubscribe</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> const *&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qevent_8h.html#af55248e13cdc5784f0824c7615c41b7d">QSignal</a>&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Un-subscribes from the delivery of signal <em>sig</em> to the active object <em>me</em>. </p>
<p>This function is part of the Publish-Subscribe event delivery mechanism available in QF. Un-subscribing from an event means that the framework will stop posting published events with a given signal <em>sig</em> to the event queue of the active object <em>me</em>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Due to the latency of event queues, an active object should NOT assume that a given signal <em>sig</em> will never be dispatched to the state machine of the active object after un-subscribing from that signal. The event might be already in the queue, or just about to be posted and the un-subscribe operation will not flush such events.</dd>
<dd>
Un-subscribing from a signal that has never been subscribed in the first place is considered an error and QF will rise an assertion.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#a569a926df9b5180cd9e03b0c9f78adcf" title="Publish event to the framework.">QF_publish()</a>, <a class="el" href="qf_8h.html#a2cb9015d643ddbf487112dfefb02eef3" title="Subscribes for delivery of signal sig to the active object me.">QActive_subscribe()</a>, and <a class="el" href="qf_8h.html#a538f489d1d1be6f6493dbff54ff87337" title="Un-subscribes from the delivery of all signals to the active object me.">QActive_unsubscribeAll()</a> </dd></dl>

<p>Definition at line <a class="el" href="qa__usub_8c_source.html#l00040">40</a> of file <a class="el" href="qa__usub_8c_source.html">qa_usub.c</a>.</p>

<p>References <a class="el" href="qassert_8h_source.html#l00173">Q_REQUIRE</a>, <a class="el" href="qep_8h_source.html#l00283">Q_USER_SIG</a>, <a class="el" href="qf__act_8c_source.html#l00041">QF_active_</a>, <a class="el" href="qf__pwr2_8c_source.html#l00077">QF_div8Lkup</a>, <a class="el" href="qf__pwr2_8c_source.html#l00057">QF_invPwr2Lkup</a>, <a class="el" href="qf__port_8h_source.html#l00053">QF_MAX_ACTIVE</a>, <a class="el" href="qf__psini_8c_source.html#l00039">QF_maxSignal_</a>, <a class="el" href="qf__pkg_8h_source.html#l00109">QF_PTR_AT_</a>, <a class="el" href="qf__psini_8c_source.html#l00038">QF_subscrList_</a>, <a class="el" href="qs___8c_source.html#l00038">QS_aoObj_</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00777">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00069">QS_QF_ACTIVE_UNSUBSCRIBE</a>, and <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>.</p>

</div>
</div>
<a class="anchor" id="a538f489d1d1be6f6493dbff54ff87337"></a><!-- doxytag: member="qf.h::QActive_unsubscribeAll" ref="a538f489d1d1be6f6493dbff54ff87337" args="(QActive const *me)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qa__usuba_8c.html#a538f489d1d1be6f6493dbff54ff87337">QActive_unsubscribeAll</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> const *&#160;</td>
          <td class="paramname"><em>me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Un-subscribes from the delivery of all signals to the active object <em>me</em>. </p>
<p>This function is part of the Publish-Subscribe event delivery mechanism available in QF. Un-subscribing from all events means that the framework will stop posting any published events to the event queue of the active object <em>me</em>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Due to the latency of event queues, an active object should NOT assume that no events will ever be dispatched to the state machine of the active object after un-subscribing from all events. The events might be already in the queue, or just about to be posted and the un-subscribe operation will not flush such events. Also, the alternative event-delivery mechanisms, such as direct event posting or time events, can be still delivered to the event queue of the active object.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#a569a926df9b5180cd9e03b0c9f78adcf" title="Publish event to the framework.">QF_publish()</a>, <a class="el" href="qf_8h.html#a2cb9015d643ddbf487112dfefb02eef3" title="Subscribes for delivery of signal sig to the active object me.">QActive_subscribe()</a>, and <a class="el" href="qf_8h.html#ab050587cf7c9786819184e423827e0ff" title="Un-subscribes from the delivery of signal sig to the active object me.">QActive_unsubscribe()</a> </dd></dl>

<p>Definition at line <a class="el" href="qa__usuba_8c_source.html#l00040">40</a> of file <a class="el" href="qa__usuba_8c_source.html">qa_usuba.c</a>.</p>

<p>References <a class="el" href="qassert_8h_source.html#l00173">Q_REQUIRE</a>, <a class="el" href="qep_8h_source.html#l00283">Q_USER_SIG</a>, <a class="el" href="qf__act_8c_source.html#l00041">QF_active_</a>, <a class="el" href="qf__pwr2_8c_source.html#l00077">QF_div8Lkup</a>, <a class="el" href="qf__pwr2_8c_source.html#l00057">QF_invPwr2Lkup</a>, <a class="el" href="qf__port_8h_source.html#l00053">QF_MAX_ACTIVE</a>, <a class="el" href="qf__psini_8c_source.html#l00039">QF_maxSignal_</a>, <a class="el" href="qf__pkg_8h_source.html#l00109">QF_PTR_AT_</a>, <a class="el" href="qf__pwr2_8c_source.html#l00037">QF_pwr2Lkup</a>, <a class="el" href="qf__psini_8c_source.html#l00038">QF_subscrList_</a>, <a class="el" href="qs___8c_source.html#l00038">QS_aoObj_</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00777">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00069">QS_QF_ACTIVE_UNSUBSCRIBE</a>, and <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>.</p>

</div>
</div>
<a class="anchor" id="aa9425659a2eb0e6f543d2405b762dcc9"></a><!-- doxytag: member="qf.h::QF_add_" ref="aa9425659a2eb0e6f543d2405b762dcc9" args="(QActive *a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qf__act_8c.html#aa9425659a2eb0e6f543d2405b762dcc9">QF_add_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register an active object to be managed by the framework. </p>
<p>This function should not be called by the application directly, only through the function <a class="el" href="qf_8h.html#a0123f02b4c1bcf7df2cc0b11dfce8b09" title="Starts execution of an active object and registers the object with the framework.">QActive_start()</a>. The priority of the active object <em>a</em> should be set before calling this function.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function raises an assertion if the priority of the active object exceeds the maximum value <a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a>. Also, this function raises an assertion if the priority of the active object is already in use. (QF requires each active object to have a UNIQUE priority.) </dd></dl>

<p>Definition at line <a class="el" href="qf__act_8c_source.html#l00058">58</a> of file <a class="el" href="qf__act_8c_source.html">qf_act.c</a>.</p>

<p>References <a class="el" href="qf_8h_source.html#l00182">QActive::prio</a>, <a class="el" href="qassert_8h_source.html#l00173">Q_REQUIRE</a>, <a class="el" href="qf__act_8c_source.html#l00041">QF_active_</a>, <a class="el" href="qf__port_8h_source.html#l00053">QF_MAX_ACTIVE</a>, <a class="el" href="qs___8c_source.html#l00038">QS_aoObj_</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00777">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00066">QS_QF_ACTIVE_ADD</a>, <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>, and <a class="el" href="qs_8h_source.html#l00753">QS_U8_</a>.</p>

<p>Referenced by <a class="el" href="qk_8c_source.html#l00086">QActive_start()</a>.</p>

</div>
</div>
<a class="anchor" id="a40fe2f66781a8ac8170f0b188b879783"></a><!-- doxytag: member="qf.h::QF_gc" ref="a40fe2f66781a8ac8170f0b188b879783" args="(QEvent const *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qf__gc_8c.html#a40fe2f66781a8ac8170f0b188b879783">QF_gc</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recycle a dynamic event. </p>
<p>This function implements a simple garbage collector for the dynamic events. Only dynamic events are candidates for recycling. (A dynamic event is one that is allocated from an event pool, which is determined as non-zero e-&gt;attrQF__ attribute.) Next, the function decrements the reference counter of the event, and recycles the event only if the counter drops to zero (meaning that no more references are outstanding for this event). The dynamic event is recycled by returning it to the pool from which it was originally allocated. The pool-of-origin information is stored in the upper 2-MSBs of the e-&gt;attrQF__ attribute.)</p>
<dl class="note"><dt><b>Note:</b></dt><dd>QF invokes the garbage collector at all appropriate contexts, when an event can become garbage (automatic garbage collection), so the application code should have no need to call <a class="el" href="qf_8h.html#a40fe2f66781a8ac8170f0b188b879783" title="Recycle a dynamic event.">QF_gc()</a> directly. The <a class="el" href="qf_8h.html#a40fe2f66781a8ac8170f0b188b879783" title="Recycle a dynamic event.">QF_gc()</a> function is exposed only for special cases when your application sends dynamic events to the "raw" thread-safe queues (see <a class="el" href="struct_q_e_queue.html" title="Native QF Event Queue.">QEQueue</a>). Such queues are processed outside of QF and the automatic garbage collection is CANNOT be performed for these events. In this case you need to call <a class="el" href="qf_8h.html#a40fe2f66781a8ac8170f0b188b879783" title="Recycle a dynamic event.">QF_gc()</a> explicitly. </dd></dl>

<p>Definition at line <a class="el" href="qf__gc_8c_source.html#l00040">40</a> of file <a class="el" href="qf__gc_8c_source.html">qf_gc.c</a>.</p>

<p>References <a class="el" href="qassert_8h_source.html#l00108">Q_ASSERT</a>, <a class="el" href="qk_8h_source.html#l00204">QF_EPOOL_PUT_</a>, <a class="el" href="qf__pkg_8h_source.html#l00097">QF_EVT_POOL_ID_</a>, <a class="el" href="qf__pkg_8h_source.html#l00100">QF_EVT_REF_CTR_</a>, <a class="el" href="qf__pkg_8h_source.html#l00106">QF_EVT_REF_CTR_DEC_</a>, <a class="el" href="qf__pool_8c_source.html#l00041">QF_maxPool_</a>, <a class="el" href="qf__pool_8c_source.html#l00040">QF_pool_</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00086">QS_QF_GC</a>, <a class="el" href="qs_8h_source.html#l00085">QS_QF_GC_ATTEMPT</a>, <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>, and <a class="el" href="qs_8h_source.html#l00753">QS_U8_</a>.</p>

<p>Referenced by <a class="el" href="qf__pspub_8c_source.html#l00043">QF_publish()</a>, <a class="el" href="qvanilla_8c_source.html#l00057">QF_run()</a>, <a class="el" href="qk__sched_8c_source.html#l00041">QK_sched_()</a>, and <a class="el" href="qk__ext_8c_source.html#l00041">QK_schedExt_()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e3571c5cb12f59994d97d5b28560934"></a><!-- doxytag: member="qf.h::QF_getPoolMargin" ref="a7e3571c5cb12f59994d97d5b28560934" args="(uint8_t poolId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="qmp__get_8c.html#a7e3571c5cb12f59994d97d5b28560934">QF_getPoolMargin</a> </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>poolId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns the margin of the given event pool. </p>
<p>This function returns the margin of the given event pool <em>poolId</em>, where poolId is the ID of the pool initialized by the call to <a class="el" href="qf_8h.html#a63817909aa88407fd7d6c1ff3706a249" title="Event pool initialization for dynamic allocation of events.">QF_poolInit()</a>. The poolId of the first initialized pool is 1, the second 2, and so on.</p>
<p>The returned pool margin is the minimal number of free blocks encountered in the given pool since system startup.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Requesting the margin of an un-initialized pool raises an assertion in the QF. </dd></dl>

<p>Definition at line <a class="el" href="qmp__get_8c_source.html#l00065">65</a> of file <a class="el" href="qmp__get_8c_source.html">qmp_get.c</a>.</p>

<p>References <a class="el" href="qassert_8h_source.html#l00173">Q_REQUIRE</a>, <a class="el" href="qf__pool_8c_source.html#l00041">QF_maxPool_</a>, and <a class="el" href="qf__pool_8c_source.html#l00040">QF_pool_</a>.</p>

</div>
</div>
<a class="anchor" id="a43b0dc29cba67147b76838144a901c38"></a><!-- doxytag: member="qf.h::QF_getPortVersion" ref="a43b0dc29cba67147b76838144a901c38" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qevent_8h.html#a40bb5262bf908c328fbcfbe5d29d0201">char_t</a> const Q_ROM* Q_ROM_VAR <a class="el" href="qf_8h.html#a43b0dc29cba67147b76838144a901c38">QF_getPortVersion</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the QF-port version. </p>
<p>This function returns constant version string in the format x.y.zz, where x (one digit) is the major version, y (one digit) is the minor version, and zz (two digits) is the maintenance release version. An example of the QF-port version string is "1.1.03".</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#ac590db3a7b49ddce526c527df2b7925f" title="Returns the QF version.">QF_getVersion()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5691094be4c3f02200e43d51535ed172"></a><!-- doxytag: member="qf.h::QF_getQueueMargin" ref="a5691094be4c3f02200e43d51535ed172" args="(uint8_t prio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="qa__get___8c.html#a5691094be4c3f02200e43d51535ed172">QF_getQueueMargin</a> </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>prio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns the margin of the given event queue. </p>
<p>This function returns the margin of the given event queue of an active object with priority <em>prio</em>. (QF priorities start with 1 and go up to <a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a>.) The margin is the minimal number of free events encountered in the given queue since system startup.</p>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="qf_8h.html#a5691094be4c3f02200e43d51535ed172" title="This function returns the margin of the given event queue.">QF_getQueueMargin()</a> is available only when the native QF event queue implementation is used. Requesting the queue margin of an unused priority level raises an assertion in the QF. (A priority level becomes used in QF after the call to the <a class="el" href="qf_8h.html#aa9425659a2eb0e6f543d2405b762dcc9" title="Register an active object to be managed by the framework.">QF_add_()</a> function.) </dd></dl>

<p>Definition at line <a class="el" href="qa__get___8c_source.html#l00087">87</a> of file <a class="el" href="qa__get___8c_source.html">qa_get_.c</a>.</p>

<p>References <a class="el" href="qassert_8h_source.html#l00173">Q_REQUIRE</a>, <a class="el" href="qf__act_8c_source.html#l00041">QF_active_</a>, and <a class="el" href="qf__port_8h_source.html#l00053">QF_MAX_ACTIVE</a>.</p>

</div>
</div>
<a class="anchor" id="ac590db3a7b49ddce526c527df2b7925f"></a><!-- doxytag: member="qf.h::QF_getVersion" ref="ac590db3a7b49ddce526c527df2b7925f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qevent_8h.html#a40bb5262bf908c328fbcfbe5d29d0201">char_t</a> const Q_ROM* Q_ROM_VAR <a class="el" href="qf__act_8c.html#ac590db3a7b49ddce526c527df2b7925f">QF_getVersion</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the QF version. </p>
<p>This function returns constant version string in the format x.y.zz, where x (one digit) is the major version, y (one digit) is the minor version, and zz (two digits) is the maintenance release version. An example of the version string is "3.1.03".</p>
<p>The following example illustrates the usage of this function: </p>
<div class="fragment"><pre class="fragment">    printf(<span class="stringliteral">&quot;Quantum DPP\nQEP %s\nQF  %s, QF port %s\n&quot;</span>
           <span class="stringliteral">&quot;Press ESC to quit...\n&quot;</span>,
           <a class="code" href="qep_8h.html#a758990e645c66113740054965ab53b78" title="obtain the current QEP version number string">QEP_getVersion</a>(),
           <a class="code" href="qf_8h.html#ac590db3a7b49ddce526c527df2b7925f" title="Returns the QF version.">QF_getVersion</a>(), <a class="code" href="qf_8h.html#a43b0dc29cba67147b76838144a901c38" title="Returns the QF-port version.">QF_getPortVersion</a>());
</pre></div> 
<p>Definition at line <a class="el" href="qf__act_8c_source.html#l00045">45</a> of file <a class="el" href="qf__act_8c_source.html">qf_act.c</a>.</p>

<p>References <a class="el" href="qevent_8h_source.html#l00047">QP_VERSION</a>.</p>

<p>Referenced by <a class="el" href="qk_8c_source.html#l00052">QK_getVersion()</a>.</p>

</div>
</div>
<a class="anchor" id="adac7eccb860d910c4e446d3143798bba"></a><!-- doxytag: member="qf.h::QF_init" ref="adac7eccb860d910c4e446d3143798bba" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qk_8c.html#adac7eccb860d910c4e446d3143798bba">QF_init</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>QF initialization. </p>
<p>This function initializes QF and must be called exactly once before any other QF function. </p>

<p>Definition at line <a class="el" href="qvanilla_8c_source.html#l00048">48</a> of file <a class="el" href="qvanilla_8c_source.html">qvanilla.c</a>.</p>

<p>References <a class="el" href="qk_8h.html#ae1fa4705c311e29699a0164a20362bf1">QK_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a2128fe3499dc6ed8100f5deed5a779a1"></a><!-- doxytag: member="qf.h::QF_new_" ref="a2128fe3499dc6ed8100f5deed5a779a1" args="(QEventSize evtSize, QSignal sig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_event.html">QEvent</a>* <a class="el" href="qf__new_8c.html#a2128fe3499dc6ed8100f5deed5a779a1">QF_new_</a> </td>
          <td>(</td>
          <td class="paramtype">QEventSize&#160;</td>
          <td class="paramname"><em>evtSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qevent_8h.html#af55248e13cdc5784f0824c7615c41b7d">QSignal</a>&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal QF implementation of the dynamic event allocator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The application code should not call this function directly. Please use the macro <a class="el" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW</a>. </dd></dl>

<p>Definition at line <a class="el" href="qf__new_8c_source.html#l00040">40</a> of file <a class="el" href="qf__new_8c_source.html">qf_new.c</a>.</p>

<p>References <a class="el" href="qassert_8h_source.html#l00108">Q_ASSERT</a>, <a class="el" href="qk_8h_source.html#l00186">QF_EPOOL_EVENT_SIZE_</a>, <a class="el" href="qk_8h_source.html#l00195">QF_EPOOL_GET_</a>, <a class="el" href="qf__pkg_8h_source.html#l00097">QF_EVT_POOL_ID_</a>, <a class="el" href="qf__pkg_8h_source.html#l00100">QF_EVT_REF_CTR_</a>, <a class="el" href="qf__pool_8c_source.html#l00041">QF_maxPool_</a>, <a class="el" href="qf__pool_8c_source.html#l00040">QF_pool_</a>, <a class="el" href="qs_8h_source.html#l00711">QS_BEGIN_</a>, <a class="el" href="qs_8h_source.html#l00645">QS_CRIT_STAT_</a>, <a class="el" href="qs_8h_source.html#l00725">QS_END_</a>, <a class="el" href="qs_8h_source.html#l00084">QS_QF_NEW</a>, <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>, and <a class="el" href="qevent_8h_source.html#l00147">QEvent::sig</a>.</p>

</div>
</div>
<a class="anchor" id="a5d7e181f2e679e1fa77c1e915fbee3e0"></a><!-- doxytag: member="qf.h::QF_onCleanup" ref="a5d7e181f2e679e1fa77c1e915fbee3e0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qf_8h.html#a5d7e181f2e679e1fa77c1e915fbee3e0">QF_onCleanup</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cleanup QF callback. </p>
<p><a class="el" href="qf_8h.html#a5d7e181f2e679e1fa77c1e915fbee3e0" title="Cleanup QF callback.">QF_onCleanup()</a> is called in some QF ports before QF returns to the underlying operating system or RTOS.</p>
<p>This function is strongly platform-specific and is not implemented in the QF, but either in the QF port or in the Board Support Package (BSP) for the given application. Some QF ports might not require implementing <a class="el" href="qf_8h.html#a5d7e181f2e679e1fa77c1e915fbee3e0" title="Cleanup QF callback.">QF_onCleanup()</a> at all, because many embedded applications don't have anything to exit to.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#adf9cb86740bf55c5ad55c1d44fd35921" title="Function invoked by the application layer to stop the QF application and return control to the OS/Ker...">QF_stop()</a> </dd></dl>

<p>Referenced by <a class="el" href="qk_8c_source.html#l00060">QF_stop()</a>.</p>

</div>
</div>
<a class="anchor" id="afcac91c9d71d70255fdd88db3fb16e24"></a><!-- doxytag: member="qf.h::QF_onIdle" ref="afcac91c9d71d70255fdd88db3fb16e24" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qf_8h.html#afcac91c9d71d70255fdd88db3fb16e24">QF_onIdle</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>QF idle callback (customized in BSPs for QF) </p>
<p><a class="el" href="qf_8h.html#afcac91c9d71d70255fdd88db3fb16e24" title="QF idle callback (customized in BSPs for QF)">QF_onIdle()</a> is called by the non-preemptive "Vanilla" scheduler built into QF when the framework detects that no events are available for active objects (the idle condition). This callback gives the application an opportunity to enter a power-saving CPU mode, or perform some other idle processing (such as Q-Spy output).</p>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="qf_8h.html#afcac91c9d71d70255fdd88db3fb16e24" title="QF idle callback (customized in BSPs for QF)">QF_onIdle()</a> is invoked with interrupts DISABLED because the idle condition can be asynchronously changed at any time by an interrupt. <a class="el" href="qf_8h.html#afcac91c9d71d70255fdd88db3fb16e24" title="QF idle callback (customized in BSPs for QF)">QF_onIdle()</a> MUST enable the interrupts internally, but not before putting the CPU into the low-power mode. (Ideally, enabling interrupts and low-power mode should happen atomically). At the very least, the function MUST enable interrupts, otherwise interrups will remain disabled permanently.</dd>
<dd>
<a class="el" href="qf_8h.html#afcac91c9d71d70255fdd88db3fb16e24" title="QF idle callback (customized in BSPs for QF)">QF_onIdle()</a> is only used by the non-preemptive "Vanilla" scheduler in the "bare metal" QF port, and is NOT used in any other QF ports. When QF is combined with QK, the QK idle loop calls a different function <a class="el" href="qk_8h.html#a667daad24b172e782fe4e2b5b06fbf61" title="QK idle callback (customized in BSPs for QK)">QK_onIdle()</a>, with different semantics than <a class="el" href="qf_8h.html#afcac91c9d71d70255fdd88db3fb16e24" title="QF idle callback (customized in BSPs for QF)">QF_onIdle()</a>. When QF is combined with a 3rd-party RTOS or kernel, the idle processing mechanism of the RTOS or kernal is used instead of <a class="el" href="qf_8h.html#afcac91c9d71d70255fdd88db3fb16e24" title="QF idle callback (customized in BSPs for QF)">QF_onIdle()</a>. </dd></dl>

<p>Referenced by <a class="el" href="qvanilla_8c_source.html#l00057">QF_run()</a>.</p>

</div>
</div>
<a class="anchor" id="a189a6d2ece787717c81fbf51fd180732"></a><!-- doxytag: member="qf.h::QF_onStartup" ref="a189a6d2ece787717c81fbf51fd180732" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qf_8h.html#a189a6d2ece787717c81fbf51fd180732">QF_onStartup</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Startup QF callback. </p>
<p>The timeline for calling <a class="el" href="qf_8h.html#a189a6d2ece787717c81fbf51fd180732" title="Startup QF callback.">QF_onStartup()</a> depends on the particular QF port. In most cases, <a class="el" href="qf_8h.html#a189a6d2ece787717c81fbf51fd180732" title="Startup QF callback.">QF_onStartup()</a> is called from <a class="el" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a>, right before starting any multitasking kernel or the background loop. </p>

<p>Referenced by <a class="el" href="qk_8c_source.html#l00075">QF_run()</a>.</p>

</div>
</div>
<a class="anchor" id="a63817909aa88407fd7d6c1ff3706a249"></a><!-- doxytag: member="qf.h::QF_poolInit" ref="a63817909aa88407fd7d6c1ff3706a249" args="(void *poolSto, uint32_t poolSize, QEventSize evtSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qf__pool_8c.html#a63817909aa88407fd7d6c1ff3706a249">QF_poolInit</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>poolSto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>poolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QEventSize&#160;</td>
          <td class="paramname"><em>evtSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Event pool initialization for dynamic allocation of events. </p>
<p>This function initializes one event pool at a time and must be called exactly once for each event pool before the pool can be used. The arguments are as follows: <em>poolSto</em> is a pointer to the memory block for the events. <em>poolSize</em> is the size of the memory block in bytes. <em>evtSize</em> is the block-size of the pool in bytes, which determines the maximum size of events that can be allocated from the pool.</p>
<p>You might initialize one, two, and up to three event pools by making one, two, or three calls to the <a class="el" href="qf_8h.html#a63817909aa88407fd7d6c1ff3706a249" title="Event pool initialization for dynamic allocation of events.">QF_poolInit()</a> function. However, for the simplicity of the internal implementation, you must initialize event pools in the ascending order of the event size.</p>
<p>Many RTOSes provide fixed block-size heaps, a.k.a. memory pools that can be adapted for QF event pools. In case such support is missing, QF provides a native QF event pool implementation. The macro <a class="el" href="qk_8h.html#ab786be96ee118929bfb4dcd51d3acce5" title="This macro defines the type of the event pool used in this QF port.">QF_EPOOL_TYPE_</a> determines the type of event pool used by a particular QF port. See structure <a class="el" href="struct_q_m_pool.html" title="Native QF Memory Pool.">QMPool</a> for more information.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The actual number of events available in the pool might be actually less than (<em>poolSize</em> / <em>evtSize</em>) due to the internal alignment of the blocks that the pool might perform. You can always check the capacity of the pool by calling <a class="el" href="qf_8h.html#a7e3571c5cb12f59994d97d5b28560934" title="This function returns the margin of the given event pool.">QF_getPoolMargin()</a>.</dd>
<dd>
The dynamic allocation of events is optional, meaning that you might choose not to use dynamic events. In that case calling <a class="el" href="qf_8h.html#a63817909aa88407fd7d6c1ff3706a249" title="Event pool initialization for dynamic allocation of events.">QF_poolInit()</a> and using up memory for the memory blocks is unnecessary.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>QF initialization example for <a class="el" href="qf_8h.html#adac7eccb860d910c4e446d3143798bba" title="QF initialization.">QF_init()</a> </dd></dl>

<p>Definition at line <a class="el" href="qf__pool_8c_source.html#l00044">44</a> of file <a class="el" href="qf__pool_8c_source.html">qf_pool.c</a>.</p>

<p>References <a class="el" href="qevent_8h_source.html#l00154">Q_DIM</a>, <a class="el" href="qassert_8h_source.html#l00173">Q_REQUIRE</a>, <a class="el" href="qk_8h_source.html#l00186">QF_EPOOL_EVENT_SIZE_</a>, <a class="el" href="qk_8h_source.html#l00176">QF_EPOOL_INIT_</a>, <a class="el" href="qf__pool_8c_source.html#l00041">QF_maxPool_</a>, and <a class="el" href="qf__pool_8c_source.html#l00040">QF_pool_</a>.</p>

</div>
</div>
<a class="anchor" id="a9f97f476eb311982be2f2e46011a04e4"></a><!-- doxytag: member="qf.h::QF_psInit" ref="a9f97f476eb311982be2f2e46011a04e4" args="(QSubscrList *subscrSto, QSignal maxSignal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qf__psini_8c.html#a9f97f476eb311982be2f2e46011a04e4">QF_psInit</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_subscr_list.html">QSubscrList</a> *&#160;</td>
          <td class="paramname"><em>subscrSto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qevent_8h.html#af55248e13cdc5784f0824c7615c41b7d">QSignal</a>&#160;</td>
          <td class="paramname"><em>maxSignal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Publish-subscribe initialization. </p>
<p>This function initializes the publish-subscribe facilities of QF and must be called exactly once before any subscriptions/publications occur in the application. The arguments are as follows: <em>subscrSto</em> is a pointer to the array of subscriber-lists. <em>maxSignal</em> is the dimension of this array and at the same time the maximum signal that can be published or subscribed.</p>
<p>The array of subscriber-lists is indexed by signals and provides mapping between the signals and subscriber-lists. The subscriber-lists are bitmasks of type <a class="el" href="struct_q_subscr_list.html" title="Subscriber-List structure.">QSubscrList</a>, each bit in the bitmask corresponding to the unique priority of an active object. The size of the <a class="el" href="struct_q_subscr_list.html" title="Subscriber-List structure.">QSubscrList</a> bitmask depends on the value of the <a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a> macro.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The publish-subscribe facilities are optional, meaning that you might choose not to use publish-subscribe. In that case calling <a class="el" href="qf_8h.html#a9f97f476eb311982be2f2e46011a04e4" title="Publish-subscribe initialization.">QF_psInit()</a> and using up memory for the subscriber-lists is unnecessary.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_q_subscr_list.html" title="Subscriber-List structure.">QSubscrList</a></dd></dl>
<p>The following example shows the typical initialization sequence of QF: </p>
<div class="fragment"><pre class="fragment"><span class="comment">/* allocate storage for active objects, event queues, event pools,</span>
<span class="comment">* subscriber lists, and stacks.</span>
<span class="comment">*/</span>
<span class="keyword">static</span> <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> <span class="keyword">const</span> *l_tableQueueSto[N_PHILO];
<span class="keyword">static</span> <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> <span class="keyword">const</span> *l_philoQueueSto[N_PHILO][N_PHILO];
<span class="keyword">static</span> <a class="code" href="struct_q_subscr_list.html" title="Subscriber-List structure.">QSubscrList</a>   l_subscrSto[MAX_PUB_SIG];

<span class="keyword">static</span> <span class="keyword">union </span>SmallEvent {
    <span class="keywordtype">void</span> *min_size;
    TableEvt te;
    <span class="comment">/* other event types to go into this pool */</span>
} l_smlPoolSto[2*N_PHILO];              <span class="comment">/* storage for the small event pool */</span>

<span class="comment">/*..........................................................................*/</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {
    uint8_t n;

    Philo_ctor();             <span class="comment">/* instantiate all Philosopher active objects */</span>
    Table_ctor();                    <span class="comment">/* instantiate the Table active object */</span>

    BSP_init(argc, argv);           <span class="comment">/* initialize the Board Support Package */</span>

    <a class="code" href="qf_8h.html#adac7eccb860d910c4e446d3143798bba" title="QF initialization.">QF_init</a>();     <span class="comment">/* initialize the framework and the underlying RT kernel */</span>

    <a class="code" href="qf_8h.html#a9f97f476eb311982be2f2e46011a04e4" title="Publish-subscribe initialization.">QF_psInit</a>(l_subscrSto, <a class="code" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_subscrSto));   <span class="comment">/* init publish-subscribe */</span>

                                               <span class="comment">/* initialize event pools... */</span>
    <a class="code" href="qf_8h.html#a63817909aa88407fd7d6c1ff3706a249" title="Event pool initialization for dynamic allocation of events.">QF_poolInit</a>(l_smlPoolSto, <span class="keyword">sizeof</span>(l_smlPoolSto), <span class="keyword">sizeof</span>(l_smlPoolSto[0]));

    <span class="keywordflow">for</span> (n = 0; n &lt; N_PHILO; ++n) {          <span class="comment">/* start the active objects... */</span>
        <a class="code" href="qf_8h.html#a0123f02b4c1bcf7df2cc0b11dfce8b09" title="Starts execution of an active object and registers the object with the framework.">QActive_start</a>(AO_Philo[n], (uint8_t)(n + 1),
                      l_philoQueueSto[n], <a class="code" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_philoQueueSto[n]),
                      (<span class="keywordtype">void</span> *)0, 0, (<a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> *)0);
    }
    <a class="code" href="qf_8h.html#a0123f02b4c1bcf7df2cc0b11dfce8b09" title="Starts execution of an active object and registers the object with the framework.">QActive_start</a>(AO_Table, (uint8_t)(N_PHILO + 1),
                  l_tableQueueSto, <a class="code" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_tableQueueSto),
                  (<span class="keywordtype">void</span> *)0, 0, (<a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> *)0);
    <a class="code" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run</a>();                                     <span class="comment">/* run the QF application */</span>

    <span class="keywordflow">return</span> 0;
}
</pre></div> 
<p>Definition at line <a class="el" href="qf__psini_8c_source.html#l00042">42</a> of file <a class="el" href="qf__psini_8c_source.html">qf_psini.c</a>.</p>

<p>References <a class="el" href="qf__psini_8c_source.html#l00039">QF_maxSignal_</a>.</p>

</div>
</div>
<a class="anchor" id="a569a926df9b5180cd9e03b0c9f78adcf"></a><!-- doxytag: member="qf.h::QF_publish" ref="a569a926df9b5180cd9e03b0c9f78adcf" args="(QEvent const *e, void const *sender)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qf__pspub_8c.html#a569a926df9b5180cd9e03b0c9f78adcf">QF_publish</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>sender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Publish event to the framework. </p>
<p>This function posts (using the FIFO policy) the event <em>e</em> to ALL active objects that have subscribed to the signal <em>e-&gt;sig</em>. This function is designed to be callable from any part of the system, including ISRs, device drivers, and active objects.</p>
<p>In the general case, event publishing requires multi-casting the event to multiple subscribers. This happens in the caller's thread with the scheduler locked to prevent preemptions during the multi-casting process. (Please note that the interrupts are not locked.)</p>
<dl class="note"><dt><b>Note:</b></dt><dd>this function should be called only via the macro <a class="el" href="qf_8h.html#afd57334f2a1664a168b0702a106e0782" title="Invoke the event publishing facility QF_publish(). This macro is the recommended way of publishing ev...">QF_PUBLISH</a> </dd></dl>

<p>Definition at line <a class="el" href="qf__pspub_8c_source.html#l00043">43</a> of file <a class="el" href="qf__pspub_8c_source.html">qf_pspub.c</a>.</p>

<p>References <a class="el" href="qf_8h_source.html#l00671">QSubscrList::bits</a>, <a class="el" href="qassert_8h_source.html#l00108">Q_ASSERT</a>, <a class="el" href="qevent_8h_source.html#l00154">Q_DIM</a>, <a class="el" href="qassert_8h_source.html#l00173">Q_REQUIRE</a>, <a class="el" href="qf_8h_source.html#l00275">QACTIVE_POST</a>, <a class="el" href="qf__act_8c_source.html#l00041">QF_active_</a>, <a class="el" href="qf__pkg_8h_source.html#l00097">QF_EVT_POOL_ID_</a>, <a class="el" href="qf__pkg_8h_source.html#l00100">QF_EVT_REF_CTR_</a>, <a class="el" href="qf__pkg_8h_source.html#l00103">QF_EVT_REF_CTR_INC_</a>, <a class="el" href="qf__gc_8c_source.html#l00040">QF_gc()</a>, <a class="el" href="qf__pwr2_8c_source.html#l00057">QF_invPwr2Lkup</a>, <a class="el" href="qf__log2_8c_source.html#l00037">QF_log2Lkup</a>, <a class="el" href="qf__psini_8c_source.html#l00039">QF_maxSignal_</a>, <a class="el" href="qf__pkg_8h_source.html#l00109">QF_PTR_AT_</a>, <a class="el" href="qf__psini_8c_source.html#l00038">QF_subscrList_</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00777">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00082">QS_QF_PUBLISH</a>, <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>, <a class="el" href="qs_8h_source.html#l00753">QS_U8_</a>, and <a class="el" href="qevent_8h_source.html#l00147">QEvent::sig</a>.</p>

</div>
</div>
<a class="anchor" id="a649efffb1de001dc75719fcf548e7045"></a><!-- doxytag: member="qf.h::QF_remove_" ref="a649efffb1de001dc75719fcf548e7045" args="(QActive const *a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qf__act_8c.html#a649efffb1de001dc75719fcf548e7045">QF_remove_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> const *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the active object from the framework. </p>
<p>This function should not be called by the application directly, only inside the QF port. The priority level occupied by the active object is freed-up and can be reused for another active object.</p>
<p>The active object that is removed from the framework can no longer participate in the publish-subscribe event exchange.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function raises an assertion if the priority of the active object exceeds the maximum value <a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a> or is not used. </dd></dl>

<p>Definition at line <a class="el" href="qf__act_8c_source.html#l00078">78</a> of file <a class="el" href="qf__act_8c_source.html">qf_act.c</a>.</p>

<p>References <a class="el" href="qf_8h_source.html#l00182">QActive::prio</a>, <a class="el" href="qassert_8h_source.html#l00173">Q_REQUIRE</a>, <a class="el" href="qf__act_8c_source.html#l00041">QF_active_</a>, <a class="el" href="qf__port_8h_source.html#l00053">QF_MAX_ACTIVE</a>, <a class="el" href="qs___8c_source.html#l00038">QS_aoObj_</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00777">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00067">QS_QF_ACTIVE_REMOVE</a>, <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>, and <a class="el" href="qs_8h_source.html#l00753">QS_U8_</a>.</p>

<p>Referenced by <a class="el" href="qk_8c_source.html#l00109">QActive_stop()</a>.</p>

</div>
</div>
<a class="anchor" id="a7a41998117b4edb760b754f5ee3f61d5"></a><!-- doxytag: member="qf.h::QF_run" ref="a7a41998117b4edb760b754f5ee3f61d5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qk_8c.html#a7a41998117b4edb760b754f5ee3f61d5">QF_run</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfers control to QF to run the application. </p>
<p><a class="el" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a> is typically called from your startup code after you initialize the QF and start at least one active object with <a class="el" href="qf_8h.html#a0123f02b4c1bcf7df2cc0b11dfce8b09" title="Starts execution of an active object and registers the object with the framework.">QActive_start()</a>. Also, QF_start() call must precede the transfer of control to <a class="el" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a>, but some QF ports might call QF_start() from <a class="el" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a>. <a class="el" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a> typically never returns to the caller.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is strongly platform-dependent and is not implemented in the QF, but either in the QF port or in the Board Support Package (BSP) for the given application. All QF ports must implement <a class="el" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a>.</dd>
<dd>
When the Quantum Kernel (QK) is used as the underlying real-time kernel for the QF, all platfrom dependencies are handled in the QK, so no porting of QF is necessary. In other words, you only need to recompile the QF platform-independent code with the compiler for your platform, but you don't need to provide any platform-specific implementation (so, no qf_port.c file is necessary). Moreover, QK implements the function <a class="el" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a> in a platform-independent way, in the modile <a class="el" href="qk_8c.html" title="QK_readySet_, QK_currPrio_, and QK_intNest_ definitions and QK_getVersion(), QF_init(), QF_run(), QF_stop(), QActive_start(), QActive_stop(), QK_schedPrio_() implementations.">qk.c</a>. </dd></dl>

<p>Definition at line <a class="el" href="qvanilla_8c_source.html#l00057">57</a> of file <a class="el" href="qvanilla_8c_source.html">qvanilla.c</a>.</p>

<p>References <a class="el" href="qa__get___8c_source.html#l00043">QActive_get_()</a>, <a class="el" href="qf__act_8c_source.html#l00041">QF_active_</a>, <a class="el" href="qf__gc_8c_source.html#l00040">QF_gc()</a>, <a class="el" href="qf__port_8h_source.html#l00182">QF_INT_DISABLE</a>, <a class="el" href="qf__port_8h_source.html#l00192">QF_INT_ENABLE</a>, <a class="el" href="qf_8h.html#afcac91c9d71d70255fdd88db3fb16e24">QF_onIdle()</a>, <a class="el" href="qf_8h.html#a189a6d2ece787717c81fbf51fd180732">QF_onStartup()</a>, <a class="el" href="qk_8h.html#a667daad24b172e782fe4e2b5b06fbf61">QK_onIdle()</a>, <a class="el" href="qpset_8h_source.html#l00162">QPSet64_findMax</a>, <a class="el" href="qpset_8h_source.html#l00132">QPSet64_notEmpty</a>, <a class="el" href="qpset_8h_source.html#l00081">QPSet8_findMax</a>, <a class="el" href="qpset_8h_source.html#l00060">QPSet8_notEmpty</a>, and <a class="el" href="qf_8h_source.html#l00144">QActive::super</a>.</p>

</div>
</div>
<a class="anchor" id="adf9cb86740bf55c5ad55c1d44fd35921"></a><!-- doxytag: member="qf.h::QF_stop" ref="adf9cb86740bf55c5ad55c1d44fd35921" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qk_8c.html#adf9cb86740bf55c5ad55c1d44fd35921">QF_stop</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function invoked by the application layer to stop the QF application and return control to the OS/Kernel. </p>
<p>This function stops the QF application. After calling this function, QF attempts to gracefully stop the application. This graceful shutdown might take some time to complete. The typical use of this funcition is for terminating the QF application to return back to the operating system or for handling fatal errors that require shutting down (and possibly re-setting) the system.</p>
<p>This function is strongly platform-specific and is not implemented in the QF, but either in the QF port or in the Board Support Package (BSP) for the given application. Some QF ports might not require implementing <a class="el" href="qf_8h.html#adf9cb86740bf55c5ad55c1d44fd35921" title="Function invoked by the application layer to stop the QF application and return control to the OS/Ker...">QF_stop()</a> at all, because many embedded applications don't have anything to exit to.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#a5d7e181f2e679e1fa77c1e915fbee3e0" title="Cleanup QF callback.">QF_onCleanup()</a> </dd></dl>

<p>Definition at line <a class="el" href="qvanilla_8c_source.html#l00052">52</a> of file <a class="el" href="qvanilla_8c_source.html">qvanilla.c</a>.</p>

<p>References <a class="el" href="qf_8h.html#a5d7e181f2e679e1fa77c1e915fbee3e0">QF_onCleanup()</a>.</p>

</div>
</div>
<a class="anchor" id="a6eb99da137293ba6960bb2eaf9965d3e"></a><!-- doxytag: member="qf.h::QF_tick" ref="a6eb99da137293ba6960bb2eaf9965d3e" args="(void const *sender)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qf__tick_8c.html#a6eb99da137293ba6960bb2eaf9965d3e">QF_tick</a> </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>sender</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Processes all armed time events at every clock tick. </p>
<p>This function must be called periodically from a time-tick ISR or from the highest-priority task so that QF can manage the timeout events.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The <a class="el" href="qf_8h.html#a6eb99da137293ba6960bb2eaf9965d3e" title="Processes all armed time events at every clock tick.">QF_tick()</a> function is not reentrant meaning that it must run to completion before it is called again. Also, <a class="el" href="qf_8h.html#a6eb99da137293ba6960bb2eaf9965d3e" title="Processes all armed time events at every clock tick.">QF_tick()</a> assumes that it never will get preempted by a task, which is always the case when it is called from an ISR or the highest-priority task.</dd>
<dd>
this function should be called only via the macro <a class="el" href="qf_8h.html#a095356f76aa32cb738325abfa55e96fc" title="Invoke the system clock tick processing QF_tick(). This macro is the recommended way of invoking cloc...">QF_TICK</a></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_q_time_evt.html" title="Time Event structure.">QTimeEvt</a>. </dd></dl>

<p>Definition at line <a class="el" href="qf__tick_8c_source.html#l00043">43</a> of file <a class="el" href="qf__tick_8c_source.html">qf_tick.c</a>.</p>

<p>References <a class="el" href="qf_8h_source.html#l00513">QTimeEvt::act</a>, <a class="el" href="qf_8h_source.html#l00519">QTimeEvt::ctr</a>, <a class="el" href="qf_8h_source.html#l00526">QTimeEvt::interval</a>, <a class="el" href="qf_8h_source.html#l00509">QTimeEvt::next</a>, <a class="el" href="qf_8h_source.html#l00505">QTimeEvt::prev</a>, <a class="el" href="qf_8h_source.html#l00275">QACTIVE_POST</a>, <a class="el" href="qte__arm_8c_source.html#l00040">QF_timeEvtListHead_</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00777">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00087">QS_QF_TICK</a>, <a class="el" href="qs_8h_source.html#l00089">QS_QF_TIMEEVT_AUTO_DISARM</a>, <a class="el" href="qs_8h_source.html#l00093">QS_QF_TIMEEVT_POST</a>, <a class="el" href="qs___8c_source.html#l00041">QS_teObj_</a>, <a class="el" href="qs___8c_source.html#l00044">QS_tickCtr_</a>, <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>, <a class="el" href="qevent_8h_source.html#l00147">QEvent::sig</a>, and <a class="el" href="qf_8h_source.html#l00501">QTimeEvt::super</a>.</p>

</div>
</div>
<a class="anchor" id="ac5e2b55e92a199f6674b0ce0a7acf66e"></a><!-- doxytag: member="qf.h::QTimeEvt_arm_" ref="ac5e2b55e92a199f6674b0ce0a7acf66e" args="(QTimeEvt *me, QActive *act, QTimeEvtCtr nTicks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qte__arm_8c.html#ac5e2b55e92a199f6674b0ce0a7acf66e">QTimeEvt_arm_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_time_evt.html">QTimeEvt</a> *&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *&#160;</td>
          <td class="paramname"><em>act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QTimeEvtCtr&#160;</td>
          <td class="paramname"><em>nTicks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Arm a time event (internal function to be used through macros only). </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#a7091744cf5947a517782c530fceebc0c" title="Arm a one-shot time event for direct event posting.">QTimeEvt_postIn</a>, <a class="el" href="qf_8h.html#ac551ecf84032c1c6799734671be01894" title="Arm a periodic time event for direct event posting.">QTimeEvt_postEvery</a>, </dd></dl>

<p>Definition at line <a class="el" href="qte__arm_8c_source.html#l00043">43</a> of file <a class="el" href="qte__arm_8c_source.html">qte_arm.c</a>.</p>

<p>References <a class="el" href="qf_8h_source.html#l00505">QTimeEvt::prev</a>, <a class="el" href="qassert_8h_source.html#l00173">Q_REQUIRE</a>, <a class="el" href="qep_8h_source.html#l00283">Q_USER_SIG</a>, <a class="el" href="qte__arm_8c_source.html#l00040">QF_timeEvtListHead_</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00777">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00088">QS_QF_TIMEEVT_ARM</a>, <a class="el" href="qs___8c_source.html#l00041">QS_teObj_</a>, and <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>.</p>

</div>
</div>
<a class="anchor" id="aa70d5d11e10b2cbcc7d7de361ab9037d"></a><!-- doxytag: member="qf.h::QTimeEvt_ctor" ref="aa70d5d11e10b2cbcc7d7de361ab9037d" args="(QTimeEvt *me, QSignal sig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="qte__ctor_8c.html#aa70d5d11e10b2cbcc7d7de361ab9037d">QTimeEvt_ctor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_time_evt.html">QTimeEvt</a> *&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qevent_8h.html#af55248e13cdc5784f0824c7615c41b7d">QSignal</a>&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The "constructor" to initialize a Time Event. </p>
<p>You should call this function exactly once for every Time Event object BEFORE arming the Time Event. The most important action performed in this function is assigning a signal to the Time Event. You can reuse the Time Event any number of times, but you should not change the signal. This is because pointers to Time Events might still be held in event queues and changing signal could to hard-to-detect errors.</p>
<p>The following example shows the invocation of <a class="el" href="qf_8h.html#aa70d5d11e10b2cbcc7d7de361ab9037d" title="The &quot;constructor&quot; to initialize a Time Event.">QTimeEvt_ctor()</a> from the "constructor" of the Philosopher active object that owns the time event </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> Philosopher_ctor(Philosopher *me) {
    <a class="code" href="qf_8h.html#a7ddf2dd243b2bc13589a9c7d22f0e253" title="protected &quot;constructor&quot; of an active object. Performs the first step of active object initialization ...">QActive_ctor</a>(&amp;me-&gt;super, (<a class="code" href="qep_8h.html#ac2c368a1ec5e2037c5f4d54f24b3da95" title="pointer to state-handler function">QStateHandler</a>)&amp;Philosopher_initial);
    <a class="code" href="qf_8h.html#aa70d5d11e10b2cbcc7d7de361ab9037d" title="The &quot;constructor&quot; to initialize a Time Event.">QTimeEvt_ctor</a>(&amp;me-&gt;timeEvt, TIMEOUT_SIG);
}
</pre></div> 
<p>Definition at line <a class="el" href="qte__ctor_8c_source.html#l00040">40</a> of file <a class="el" href="qte__ctor_8c_source.html">qte_ctor.c</a>.</p>

<p>References <a class="el" href="qassert_8h_source.html#l00173">Q_REQUIRE</a>, <a class="el" href="qep_8h_source.html#l00283">Q_USER_SIG</a>, and <a class="el" href="qf__pkg_8h_source.html#l00097">QF_EVT_POOL_ID_</a>.</p>

</div>
</div>
<a class="anchor" id="a974e633dccc976194e2df8d46e972779"></a><!-- doxytag: member="qf.h::QTimeEvt_ctr" ref="a974e633dccc976194e2df8d46e972779" args="(QTimeEvt const *me)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QTimeEvtCtr <a class="el" href="qte__ctr_8c.html#a974e633dccc976194e2df8d46e972779">QTimeEvt_ctr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_time_evt.html">QTimeEvt</a> const *&#160;</td>
          <td class="paramname"><em>me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current value of the down-counter of a time event. </p>
<p>If the time event is armed, the function returns the current value of the down-counter of the given time event. If the time event is not armed, the function returns 0.</p>
<p>/note The function is thread-safe. </p>

<p>Definition at line <a class="el" href="qte__ctr_8c_source.html#l00037">37</a> of file <a class="el" href="qte__ctr_8c_source.html">qte_ctr.c</a>.</p>

<p>References <a class="el" href="qf_8h_source.html#l00513">QTimeEvt::act</a>, <a class="el" href="qf_8h_source.html#l00519">QTimeEvt::ctr</a>, <a class="el" href="qf_8h_source.html#l00526">QTimeEvt::interval</a>, <a class="el" href="qf_8h_source.html#l00505">QTimeEvt::prev</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00777">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00094">QS_QF_TIMEEVT_CTR</a>, <a class="el" href="qs___8c_source.html#l00041">QS_teObj_</a>, and <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>.</p>

</div>
</div>
<a class="anchor" id="a30bbb5b62b4271afc94725b651b326d6"></a><!-- doxytag: member="qf.h::QTimeEvt_disarm" ref="a30bbb5b62b4271afc94725b651b326d6" args="(QTimeEvt *me)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="qte__darm_8c.html#a30bbb5b62b4271afc94725b651b326d6">QTimeEvt_disarm</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_time_evt.html">QTimeEvt</a> *&#160;</td>
          <td class="paramname"><em>me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disarm a time event. </p>
<p>The time event <em>me</em> gets disarmed and can be reused. The function returns 1 (TRUE) if the time event was truly disarmed, that is, it was running. The return of 0 (FALSE) means that the time event was not truly disarmed because it was not running. The FALSE return is only possible for one-shot time events that have been automatically disarmed upon expiration. In this case the FALSE return means that the time event has already been posted or published and should be expected in the active object's state machine. </p>

<p>Definition at line <a class="el" href="qte__darm_8c_source.html#l00038">38</a> of file <a class="el" href="qte__darm_8c_source.html">qte_darm.c</a>.</p>

<p>References <a class="el" href="qf_8h_source.html#l00513">QTimeEvt::act</a>, <a class="el" href="qf_8h_source.html#l00519">QTimeEvt::ctr</a>, <a class="el" href="qf_8h_source.html#l00526">QTimeEvt::interval</a>, <a class="el" href="qf_8h_source.html#l00509">QTimeEvt::next</a>, <a class="el" href="qf_8h_source.html#l00505">QTimeEvt::prev</a>, <a class="el" href="qte__arm_8c_source.html#l00040">QF_timeEvtListHead_</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00777">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00091">QS_QF_TIMEEVT_DISARM</a>, <a class="el" href="qs_8h_source.html#l00090">QS_QF_TIMEEVT_DISARM_ATTEMPT</a>, <a class="el" href="qs___8c_source.html#l00041">QS_teObj_</a>, and <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>.</p>

</div>
</div>
<a class="anchor" id="a41a513d4b6b5333b6eddad0737dd30df"></a><!-- doxytag: member="qf.h::QTimeEvt_rearm" ref="a41a513d4b6b5333b6eddad0737dd30df" args="(QTimeEvt *me, QTimeEvtCtr nTicks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="qte__rarm_8c.html#a41a513d4b6b5333b6eddad0737dd30df">QTimeEvt_rearm</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_time_evt.html">QTimeEvt</a> *&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QTimeEvtCtr&#160;</td>
          <td class="paramname"><em>nTicks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rearm a time event. </p>
<p>The time event <em>me</em> gets rearmed with a new number of clock ticks <em>nTicks</em>. This facility can be used to prevent a one-shot time event from expiring (e.g., a watchdog time event), or to adjusts the current period of a periodic time event. Rearming a periodic timer leaves the interval unchanged and is a convenient method to adjust the phasing of the periodic time event.</p>
<p>The function returns 1 (TRUE) if the time event was running as it was re-armed. The return of 0 (FALSE) means that the time event was not truly rearmed because it was not running. The FALSE return is only possible for one-shot time events that have been automatically disarmed upon expiration. In this case the FALSE return means that the time event has already been posted or published and should be expected in the active object's state machine. </p>

<p>Definition at line <a class="el" href="qte__rarm_8c_source.html#l00040">40</a> of file <a class="el" href="qte__rarm_8c_source.html">qte_rarm.c</a>.</p>

<p>References <a class="el" href="qf_8h_source.html#l00505">QTimeEvt::prev</a>, <a class="el" href="qassert_8h_source.html#l00173">Q_REQUIRE</a>, <a class="el" href="qep_8h_source.html#l00283">Q_USER_SIG</a>, <a class="el" href="qte__arm_8c_source.html#l00040">QF_timeEvtListHead_</a>, <a class="el" href="qs_8h_source.html#l00736">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00748">QS_END_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00777">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00092">QS_QF_TIMEEVT_REARM</a>, <a class="el" href="qs___8c_source.html#l00041">QS_teObj_</a>, <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>, and <a class="el" href="qs_8h_source.html#l00753">QS_U8_</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a563e9f8e405ba684acba0b8f1a3ad9a6"></a><!-- doxytag: member="qf.h::QF_active_" ref="a563e9f8e405ba684acba0b8f1a3ad9a6" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_active.html">QActive</a>* <a class="el" href="qf__act_8c.html#a0b0bd37076b2c1bf7294e28ea1b5addd">QF_active_</a>[]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>array of registered active objects </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Not to be used by Clients directly, only in ports of QF </dd></dl>

<p>Definition at line <a class="el" href="qf__act_8c_source.html#l00041">41</a> of file <a class="el" href="qf__act_8c_source.html">qf_act.c</a>.</p>

<p>Referenced by <a class="el" href="qa__sub_8c_source.html#l00040">QActive_subscribe()</a>, <a class="el" href="qa__usub_8c_source.html#l00040">QActive_unsubscribe()</a>, <a class="el" href="qa__usuba_8c_source.html#l00040">QActive_unsubscribeAll()</a>, <a class="el" href="qf__act_8c_source.html#l00058">QF_add_()</a>, <a class="el" href="qa__get___8c_source.html#l00087">QF_getQueueMargin()</a>, <a class="el" href="qf__pspub_8c_source.html#l00043">QF_publish()</a>, <a class="el" href="qf__act_8c_source.html#l00078">QF_remove_()</a>, <a class="el" href="qvanilla_8c_source.html#l00057">QF_run()</a>, <a class="el" href="qk__sched_8c_source.html#l00041">QK_sched_()</a>, and <a class="el" href="qk__ext_8c_source.html#l00041">QK_schedExt_()</a>.</p>

</div>
</div>
<a class="anchor" id="a765803e2ff8d3550b3334efe9c366709"></a><!-- doxytag: member="qf.h::QF_div8Lkup" ref="a765803e2ff8d3550b3334efe9c366709" args="[65]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t const Q_ROM Q_ROM_VAR <a class="el" href="qf__pwr2_8c.html#a765803e2ff8d3550b3334efe9c366709">QF_div8Lkup</a>[65]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lookup table for (n-1)/8. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Index range n = 0..64. The first index (n == 0) should never be used. </dd></dl>

<p>Definition at line <a class="el" href="qf__pwr2_8c_source.html#l00077">77</a> of file <a class="el" href="qf__pwr2_8c_source.html">qf_pwr2.c</a>.</p>

<p>Referenced by <a class="el" href="qa__sub_8c_source.html#l00040">QActive_subscribe()</a>, <a class="el" href="qa__usub_8c_source.html#l00040">QActive_unsubscribe()</a>, and <a class="el" href="qa__usuba_8c_source.html#l00040">QActive_unsubscribeAll()</a>.</p>

</div>
</div>
<a class="anchor" id="a01186f1b8051d6e98c86f76bd9d95f32"></a><!-- doxytag: member="qf.h::QF_invPwr2Lkup" ref="a01186f1b8051d6e98c86f76bd9d95f32" args="[65]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t const Q_ROM Q_ROM_VAR <a class="el" href="qf__pwr2_8c.html#a01186f1b8051d6e98c86f76bd9d95f32">QF_invPwr2Lkup</a>[65]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lookup table for ~(1 &lt;&lt; ((n-1) % 8)), where n is the index into the table. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Index range n = 0..64. The first index (n == 0) should never be used. </dd></dl>

<p>Definition at line <a class="el" href="qf__pwr2_8c_source.html#l00057">57</a> of file <a class="el" href="qf__pwr2_8c_source.html">qf_pwr2.c</a>.</p>

<p>Referenced by <a class="el" href="qa__usub_8c_source.html#l00040">QActive_unsubscribe()</a>, <a class="el" href="qa__usuba_8c_source.html#l00040">QActive_unsubscribeAll()</a>, and <a class="el" href="qf__pspub_8c_source.html#l00043">QF_publish()</a>.</p>

</div>
</div>
<a class="anchor" id="ab47e1f0b5f8a97bc75f7ff7d62c5e18f"></a><!-- doxytag: member="qf.h::QF_log2Lkup" ref="ab47e1f0b5f8a97bc75f7ff7d62c5e18f" args="[256]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t const Q_ROM Q_ROM_VAR <a class="el" href="qf__log2_8c.html#ab47e1f0b5f8a97bc75f7ff7d62c5e18f">QF_log2Lkup</a>[256]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lookup table for (log2(n) + 1), where n is the index into the table. </p>
<p>This lookup delivers the 1-based number of the most significant 1-bit of a byte.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Index range n = 0..255. The first index (n == 0) should never be used. </dd></dl>

<p>Definition at line <a class="el" href="qf__log2_8c_source.html#l00037">37</a> of file <a class="el" href="qf__log2_8c_source.html">qf_log2.c</a>.</p>

<p>Referenced by <a class="el" href="qf__pspub_8c_source.html#l00043">QF_publish()</a>.</p>

</div>
</div>
<a class="anchor" id="a2091dd1ed771cbef5ca70e1542829cc4"></a><!-- doxytag: member="qf.h::QF_pwr2Lkup" ref="a2091dd1ed771cbef5ca70e1542829cc4" args="[65]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t const Q_ROM Q_ROM_VAR <a class="el" href="qf__pwr2_8c.html#a2091dd1ed771cbef5ca70e1542829cc4">QF_pwr2Lkup</a>[65]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lookup table for (1 &lt;&lt; ((n-1) % 8)), where n is the index into the table. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Index range n = 0..64. The first index (n == 0) should never be used. </dd></dl>

<p>Definition at line <a class="el" href="qf__pwr2_8c_source.html#l00037">37</a> of file <a class="el" href="qf__pwr2_8c_source.html">qf_pwr2.c</a>.</p>

<p>Referenced by <a class="el" href="qa__sub_8c_source.html#l00040">QActive_subscribe()</a>, and <a class="el" href="qa__usuba_8c_source.html#l00040">QActive_unsubscribeAll()</a>.</p>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 30 2012 22:21:51 for QP/C by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>

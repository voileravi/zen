/*****************************************************************************
* Model: dpp.qm
* File:  ./table.c
*
* This file has been generated automatically by QP Modeler (QM).
* DO NOT EDIT THIS FILE MANUALLY.
*
* Please visit www.state-machine.com/qm for more information.
*****************************************************************************/
#include "qp_port.h"
#include "dpp.h"
#include "bsp.h"

Q_DEFINE_THIS_FILE

/* Active object class -----------------------------------------------------*/
/* @(/2/1) .................................................................*/
typedef struct TableTag {
/* protected: */
    QActive super;

/* private: */
    uint8_t fork[N_PHILO];
    uint8_t isHungry[N_PHILO];
} Table;

/* public: */
void Table_ctor(void);

/* protected: */
QState Table_initial(Table *me, QEvent const *e);
QState Table_serving(Table *me, QEvent const *e);


#define RIGHT(n_) ((uint8_t)(((n_) + (N_PHILO - 1)) % N_PHILO))
#define LEFT(n_)  ((uint8_t)(((n_) + 1) % N_PHILO))
enum ForkState { FREE, USED };

/* Local objects -----------------------------------------------------------*/
static Table l_table;     /* the single instance of the Table active object */

/* Global-scope objects ----------------------------------------------------*/
QActive * const AO_Table = (QActive *)&l_table;      /* "opaque" AO pointer */

/*..........................................................................*/
/* @(/2/1) .................................................................*/
/* @(/2/1/2) ...............................................................*/
void Table_ctor(void) {
    uint8_t n;
    Table *me = &l_table;

    QActive_ctor(&me->super, (QStateHandler)&Table_initial);

    for (n = 0; n < N_PHILO; ++n) {
        me->fork[n] = FREE;
        me->isHungry[n] = 0;
    }
}
/* @(/2/1/3) ...............................................................*/
/* @(/2/1/3/0) */
QState Table_initial(Table *me, QEvent const *e) {
    (void)e; /* suppress the compiler warning about unused parameter */

    QS_OBJ_DICTIONARY(&l_table);
    QS_FUN_DICTIONARY(&QHsm_top);
    QS_FUN_DICTIONARY(&Table_initial);
    QS_FUN_DICTIONARY(&Table_serving);

    QS_SIG_DICTIONARY(DONE_SIG,      0); /* global signals */
    QS_SIG_DICTIONARY(EAT_SIG,       0);
    QS_SIG_DICTIONARY(TERMINATE_SIG, 0);

    QS_SIG_DICTIONARY(HUNGRY_SIG,    me); /* signal just for Table */

    QActive_subscribe((QActive *)me, DONE_SIG);
    QActive_subscribe((QActive *)me, TERMINATE_SIG);
    return Q_TRAN(&Table_serving);
}
/* @(/2/1/3/1) .............................................................*/
QState Table_serving(Table *me, QEvent const *e) {
    switch (e->sig) {
        /* @(/2/1/3/1/0) */
        case HUNGRY_SIG: {
            uint8_t n, m;

            BSP_busyDelay();
            n = ((TableEvt const *)e)->philoNum;
            /* phil ID must be in range and he must be not hungry */
            Q_ASSERT((n < N_PHILO) && (!me->isHungry[n]));

            BSP_displyPhilStat(n, "hungry  ");
            m = LEFT(n);
            /* @(/2/1/3/1/0/0) */
            if ((me->fork[m] == FREE) && (me->fork[n] == FREE)) {
                TableEvt *pe;
                me->fork[m] = me->fork[n] = USED;
                pe = Q_NEW(TableEvt, EAT_SIG);
                pe->philoNum = n;
                QF_PUBLISH((QEvent *)pe, me);
                BSP_displyPhilStat(n, "eating  ");
                return Q_HANDLED();
            }
            /* @(/2/1/3/1/0/1) */
            else {
                me->isHungry[n] = 1;
                return Q_HANDLED();
            }
        }
        /* @(/2/1/3/1/1) */
        case DONE_SIG: {
            uint8_t n, m;
            TableEvt *pe;

            BSP_busyDelay();
            n = ((TableEvt const *)e)->philoNum;
            /* phil ID must be in range and he must be not hungry */
            Q_ASSERT((n < N_PHILO) && (!me->isHungry[n]));

            BSP_displyPhilStat(n, "thinking");
            m = LEFT(n);
            /* both forks of Phil[n] must be used */
            Q_ASSERT((me->fork[n] == USED) && (me->fork[m] == USED));

            me->fork[m] = me->fork[n] = FREE;
            m = RIGHT(n); /* check the right neighbor */

            if (me->isHungry[m] && (me->fork[m] == FREE)) {
                me->fork[n] = me->fork[m] = USED;
                me->isHungry[m] = 0;
                pe = Q_NEW(TableEvt, EAT_SIG);
                pe->philoNum = m;
                QF_PUBLISH((QEvent *)pe, me);
                BSP_displyPhilStat(m, "eating  ");
            }
            m = LEFT(n); /* check the left neighbor */
            n = LEFT(m); /* left fork of the left neighbor */
            if (me->isHungry[m] && (me->fork[n] == FREE)) {
                me->fork[m] = me->fork[n] = USED;
                me->isHungry[m] = 0;
                pe = Q_NEW(TableEvt, EAT_SIG);
                pe->philoNum = m;
                QF_PUBLISH((QEvent *)pe, me);
                BSP_displyPhilStat(m, "eating  ");
            }
            return Q_HANDLED();
        }
        /* @(/2/1/3/1/2) */
        case TERMINATE_SIG: {
            QF_stop();
            return Q_HANDLED();
        }
        /* @(/2/1/3/1/3) */
        case EAT_SIG: {
            Q_ERROR();
            return Q_HANDLED();
        }
    }
    return Q_SUPER(&QHsm_top);
}

